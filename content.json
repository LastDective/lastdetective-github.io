{"pages":[],"posts":[{"title":"DevOps学习记录","text":"","link":"/2022/06/06/DevOps%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"Docker安装Elastic-Search","text":"启动命令1docker run -p 9200:9200 -p 9300:9300 -e &quot;ES_JAVA_OPTS=-Xms256m -Xmx512m&quot; -e &quot;discovery.type=single-node&quot; -d docker.io/elasticsearch:7.4.2","link":"/2019/11/04/Docker%E5%AE%89%E8%A3%85Elastic-Search/"},{"title":"ES6箭头函数","text":"箭头函数是ES6版本的JavaScript新特性，没有自己的this, arguments。箭头函数更适合那些需要匿名函数的地方，并且它们不能用作构造函数。 一、更简洁的函数下面是一个箭头函数的例子 1234567891011121314151617181920212223242526272829303132333435363738394041// 定义一个数组var carBrands = [ &quot;BMW&quot;, &quot;BENZ&quot;, &quot;REAULT&quot;, &quot;HONDA&quot;]/** * 下面三种调用方式的作用是一样的 */carBrands.map(function (carBrand) { console.log(carBrand.length);})carBrands.map((carBrand) =&gt; { console.log(carBrand.length)});carBrands.map(carBrand =&gt; console.log(carBrand.length))// 如果函数箭头不需要参数或需要多个参数，就使用圆括号代表参数部分var f = () =&gt; 5;// 等同于var f = function() { return 5;};// 多个参数的情况var sub = (num1, num2) =&gt; num1 - num2;// 等同于var sub = function(num1, num2) { return num1 - num2;}// 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加括号var student = () =&gt;({id:&quot;12312&quot;, name:&quot;张三&quot;})// 箭头函数让判断变得更加简洁const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n; 二、不绑定this箭头函数出现之前，每个新定义的函数都有它自己的 this值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined，如果该函数被作为“对象方法”调用则为基础对象等）。This被证明是令人厌烦的面向对象风格的编程。 123456789101112function Person() { // Person() 构造函数定义 `this`作为它自己的实例. this.age = 0; setInterval(function growUp() { // 在非严格模式, growUp()函数定义 `this`作为全局对象, // 与在 Person()构造函数中定义的 `this`并不相同. this.age++; }, 1000);}var p = new Person(); 在ECMAScript 3/5中，通过将this值分配给封闭的变量，可以解决this问题。 123456789function Person() { var that = this; that.age = 0; setInterval(function growUp() { // 回调引用的是`that`变量, 其值是预期的对象. that.age++; }, 1000);} 或者，可以创建绑定函数，以便将预先分配的this值传递到绑定的目标函数（上述示例中的growUp()函数）。 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同： 123456789function Person(){ this.age = 0; setInterval(() =&gt; { this.age++; // |this| 正确地指向person 对象 }, 1000);}var p = new Person();","link":"/2018/12/10/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"title":"ElasticsSearch例子","text":"查询原始数据结构如下 这是一个银行账户的索引 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113{ &quot;state&quot;:&quot;open&quot;, &quot;settings&quot;:{ &quot;index&quot;:{ &quot;creation_date&quot;:&quot;1590560065840&quot;, &quot;number_of_shards&quot;:&quot;1&quot;, &quot;number_of_replicas&quot;:&quot;1&quot;, &quot;uuid&quot;:&quot;qJ2GvjkCTXG5hkL-puXqQA&quot;, &quot;version&quot;:{ &quot;created&quot;:&quot;7070099&quot; }, &quot;provided_name&quot;:&quot;bank&quot; } }, &quot;mappings&quot;:{ &quot;_doc&quot;:{ &quot;properties&quot;:{ &quot;account_number&quot;:{ &quot;type&quot;:&quot;long&quot; }, &quot;firstname&quot;:{ &quot;type&quot;:&quot;text&quot;, &quot;fields&quot;:{ &quot;keyword&quot;:{ &quot;ignore_above&quot;:256, &quot;type&quot;:&quot;keyword&quot; } } }, &quot;address&quot;:{ &quot;type&quot;:&quot;text&quot;, &quot;fields&quot;:{ &quot;keyword&quot;:{ &quot;ignore_above&quot;:256, &quot;type&quot;:&quot;keyword&quot; } } }, &quot;balance&quot;:{ &quot;type&quot;:&quot;long&quot; }, &quot;gender&quot;:{ &quot;type&quot;:&quot;text&quot;, &quot;fields&quot;:{ &quot;keyword&quot;:{ &quot;ignore_above&quot;:256, &quot;type&quot;:&quot;keyword&quot; } } }, &quot;city&quot;:{ &quot;type&quot;:&quot;text&quot;, &quot;fields&quot;:{ &quot;keyword&quot;:{ &quot;ignore_above&quot;:256, &quot;type&quot;:&quot;keyword&quot; } } }, &quot;employer&quot;:{ &quot;type&quot;:&quot;text&quot;, &quot;fields&quot;:{ &quot;keyword&quot;:{ &quot;ignore_above&quot;:256, &quot;type&quot;:&quot;keyword&quot; } } }, &quot;state&quot;:{ &quot;type&quot;:&quot;text&quot;, &quot;fields&quot;:{ &quot;keyword&quot;:{ &quot;ignore_above&quot;:256, &quot;type&quot;:&quot;keyword&quot; } } }, &quot;age&quot;:{ &quot;type&quot;:&quot;long&quot; }, &quot;email&quot;:{ &quot;type&quot;:&quot;text&quot;, &quot;fields&quot;:{ &quot;keyword&quot;:{ &quot;ignore_above&quot;:256, &quot;type&quot;:&quot;keyword&quot; } } }, &quot;lastname&quot;:{ &quot;type&quot;:&quot;text&quot;, &quot;fields&quot;:{ &quot;keyword&quot;:{ &quot;ignore_above&quot;:256, &quot;type&quot;:&quot;keyword&quot; } } } } } }, &quot;aliases&quot;:[ ], &quot;primary_terms&quot;:{ &quot;0&quot;:1 }, &quot;in_sync_allocations&quot;:{ &quot;0&quot;:[ &quot;0xyG_6vxQ2WWQ6Z0lGVFBQ&quot; ] }} 查询所有账户，并按账户号码升序排序 1234567GET /bank/_search{ &quot;query&quot;: { &quot;match_all&quot;: {} }, &quot;sort&quot;: [ { &quot;account_number&quot;: &quot;asc&quot; } ]} 默认情况下，返回 10 条数据，可以通过指定 size 参数来改变返回的最大数量 分页查询 123456789GET /bank/_search{ &quot;query&quot;: { &quot;match_all&quot;: {} }, &quot;sort&quot;: [ { &quot;account_number&quot;: &quot;asc&quot; } ], &quot;from&quot;: 10, &quot;size&quot;: 10} 模糊匹配 123456GET /bank/_search{ &quot;query&quot;: { &quot;match&quot;: { &quot;address&quot;: &quot;mill lane&quot; } }} 返回地址中包含 mill 和 lane 的记录 复合查询 12345678910111213GET /bank/_search{ &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: [ { &quot;match&quot;: { &quot;age&quot;: &quot;40&quot; } } ], &quot;must_not&quot;: [ { &quot;match&quot;: { &quot;state&quot;: &quot;ID&quot; } } ] } }} 返回所有年龄在 40 岁，但是没有居住在 ID (爱荷华州) 注意 must 、should 会影响评分 must_not 不会影响评分 范围查询 12345678910111213141516GET /bank/_search{ &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: { &quot;match_all&quot;: {} }, &quot;filter&quot;: { &quot;range&quot;: { &quot;balance&quot;: { &quot;gte&quot;: 20000, &quot;lte&quot;: 30000 } } } } }} 查询出工资在 [20000,30000] 的数据 查出每个州的账户数量 1234567891011GET /bank/_search{ &quot;size&quot;: 0, &quot;aggs&quot;: { &quot;group_by_state&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;state.keyword&quot; } } }} 返回结果如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455{ &quot;took&quot;: 29, &quot;timed_out&quot;: false, &quot;_shards&quot;: { &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;skipped&quot; : 0, &quot;failed&quot;: 0 }, &quot;hits&quot; : { &quot;total&quot; : { &quot;value&quot;: 1000, &quot;relation&quot;: &quot;eq&quot; }, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] }, &quot;aggregations&quot; : { &quot;group_by_state&quot; : { &quot;doc_count_error_upper_bound&quot;: 20, &quot;sum_other_doc_count&quot;: 770, &quot;buckets&quot; : [ { &quot;key&quot; : &quot;ID&quot;, &quot;doc_count&quot; : 27 }, { &quot;key&quot; : &quot;TX&quot;, &quot;doc_count&quot; : 27 }, { &quot;key&quot; : &quot;AL&quot;, &quot;doc_count&quot; : 25 }, { &quot;key&quot; : &quot;MD&quot;, &quot;doc_count&quot; : 25 }, { &quot;key&quot; : &quot;TN&quot;, &quot;doc_count&quot; : 23 }, { &quot;key&quot; : &quot;MA&quot;, &quot;doc_count&quot; : 21 }, { &quot;key&quot; : &quot;NC&quot;, &quot;doc_count&quot; : 21 }, { &quot;key&quot; : &quot;ND&quot;, &quot;doc_count&quot; : 21 }, { &quot;key&quot; : &quot;ME&quot;, &quot;doc_count&quot; : 20 }, { &quot;key&quot; : &quot;MO&quot;, &quot;doc_count&quot; : 20 } ] } }} 由于查询的时候指定 size=0，所以 hits 字段长度为 0。 返回每个州的的账户数量，以及平均工资 123456789101112131415161718GET /bank/_search{ &quot;size&quot;: 0, &quot;aggs&quot;: { &quot;group_by_state&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;state.keyword&quot; }, &quot;aggs&quot;: { &quot;average_balance&quot;: { &quot;avg&quot;: { &quot;field&quot;: &quot;balance&quot; } } } } }} 指定已平均工资降序排序 123456789101112131415161718192021GET /bank/_search{ &quot;size&quot;: 0, &quot;aggs&quot;: { &quot;group_by_state&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;state.keyword&quot;, &quot;order&quot;: { &quot;average_balance&quot;: &quot;desc&quot; } }, &quot;aggs&quot;: { &quot;average_balance&quot;: { &quot;avg&quot;: { &quot;field&quot;: &quot;balance&quot; } } } } }}","link":"/2020/05/27/ElasticsSearch%E5%9F%BA%E7%A1%80/"},{"title":"HashMap面试题","text":"问题一为什么容量一定是2的幂？1hash &amp; (length-1) 如果 length = 16，则 length-1 = 15=1111; 如果hash 是一个32 位的整数，最后四位是 1001 …. …. …. 1001 &amp; 1111 ​ 1001 所以使用这种按位与的方法很容易，求出 hash % length 的值 JAVA 8 HashMap的改进 数组+链表/红黑树 扩容时插入顺序的改进 函数方法 ​ forEach ​ compute系列 Map的新Api ​ merge ​ replace","link":"/2020/12/24/HashMap%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"JAVA lambada表达式查询分组中的最大值","text":"查询出每个班级年龄最大的学生和年龄最小的学生 1234567891011121314151617181920212223//public class MaxByMinBy { public static void main(String[] args) { Student student = new Student(&quot;Bruce&quot;, 27, &quot;A&quot;); Student student1 = new Student(&quot;Michael&quot;, 23, &quot;A&quot;); Student student2 = new Student(&quot;Lee&quot;, 22, &quot;B&quot;); Student student3 = new Student(&quot;Lucy&quot;, 25, &quot;B&quot;); List&lt;Student&gt; students = Arrays.asList(student, student1, student2, student3); Comparator&lt;Student&gt; ageComparator = Comparator.comparing(Student::getAge);// 查询年纪最小 使用 minBy Map&lt;String, Optional&lt;Student&gt;&gt; collect = students.stream().collect(Collectors.groupingBy(Student::getClassName, Collectors.reducing(BinaryOperator.maxBy(ageComparator)))); collect.forEach((k, v) -&gt; System.out.println(&quot;Class:&quot; + k + &quot; Age:&quot; + v.get().getAge() + &quot; Name:&quot; + v.get().getName())); } @Data @AllArgsConstructor static class Student { private String name; private Integer age; private String className; }} 运行结果 12Class:A Age:27 Name:BruceClass:B Age:25 Name:Lucy","link":"/2022/11/12/JAVA-lambada%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2%E5%88%86%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"title":"JWT Token基础","text":"","link":"/2020/07/21/JWT-Token%E5%9F%BA%E7%A1%80/"},{"title":"JavaScript添加点击事件","text":"方法一 使用 onclick 事件1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button id=&quot;mybutton&quot;&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var newButton = document.getElementById(&quot;mybutton&quot;); // 绑定 oncclick 事件 newButton.onclick = function () { alert(&quot;onclick&quot;); }&lt;/script&gt;&lt;/html&gt; 运行结果如下 方法二 使用 click 方法click 方法，模拟鼠标点击 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button id=&quot;mybutton&quot;&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var newButton = document.getElementById(&quot;mybutton&quot;); newButton.onclick = function () { alert(&quot;onclick&quot;); } // 直接打开页面就会执行 click 方法，同时会触发上面的 onclick 事件 // 注意下面的语句不是绑定事件 而是 模拟点击鼠标的动作 newButton.click(alert(&quot;click&quot;))&lt;/script&gt;&lt;/html&gt; 方法三 使用 addEventListener 来绑定事件 （推荐使用）12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button id=&quot;mybutton&quot;&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var newButton = document.getElementById(&quot;mybutton&quot;); // 推荐使用这种方法 newButton.addEventListener(&quot;click&quot;,function () { alert(&quot;addEventListener&quot;); }, false);&lt;/script&gt;&lt;/html&gt; 运行结果： 为什么使用这种方法，以下来自 MDN addEventListener() 是 W3C DOM 规范中提供的注册事件监听器的方法。它的优点包括： 它允许给一个事件注册多个监听器。 特别是在使用AJAX库，JavaScript模块，或其他需要第三方库/插件的代码。 它提供了一种更精细的手段控制listener 的触发阶段。（即可以选择捕获或者冒泡）。 它对任何 DOM 元素都是有效的，而不仅仅只对 HTML 元素有效。","link":"/2018/12/22/JavaScript%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/"},{"title":"Linux下安装MySql","text":"软件准备一、软件准备Linux 版本：CentOS 7 MySql 版本 MySql 5.7 MySql 下载地址： 1https://dev.mysql.com/downloads/mysql/5.7.html#downloads 选择如下版本 二、安装过程1. 将下载好的mysql 安装文件上传，使用如下命令解压1tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar 解压完成后的文件列表如下 2. 安装mysql1yum install mysql-*.rpm 安装过程中一路输入y。 3. 启动和关闭mysql1234## 启动service mysqld start## 关闭service mysqld stop ###4. 设置密码 mysql 安装好之后，系统会自动生成一个临时的密码，使用如下命令来查看 123456grep 'password' /var/log/mysqld.log |head -n 1## 显示的临时密码如下A temporary password is generated for root@localhost: RqWlxls3p.+c## 用这个临时密码登录,输入如下命令mysql -u root -p## 输入上面的命令和密码即可登录 登录完成后进行数据库操作 12mysql&gt; show databases;2 ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 上面的命令提示必须首先修改密码，使用如下的命令来修改 1alter user user() identified by &quot;Ds343242+4@&quot;; 注意：密码必须使用 大写字母+数字+字母+特殊字符的组合，不让不能通过检验。也可以使用如下命令来降低安全策略的限制 12set global validate_password_policy=0;set global validate_password_length=1; 下次使用命令行登录 mySql 时使用如下命令 1234[root@instance-oje799dw local]# mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g..... 三、远程登录配置mySql 安装好之后，如果使用其他机器连接可能会出现如下报错： 1Host * is not allowed to connect to this MySQL server 这是因为 mySql 安全性的考虑。 使用如下方法解决 1234567## 先用命令行登录 MySqlmysql -u root -p## 设置权限use mysqlupdate user set host = '%' where user = 'root';## 刷新权限，这一步很关键，不让不会起效FLUSH PRIVILEGES; 执行上面的命令之后，就可以远程链接MySQL了。","link":"/2019/05/17/Linux%E4%B8%8B%E5%AE%89%E8%A3%85MySql/"},{"title":"MysqlExplain的type字段","text":"join typemysql 使用 explain 命令进行分析时 type 字段会有下面几种 join type类型 查询效率由好到差 system 这个表只有一行（这个表是系统表），这是 join type = const 的一种特殊形式 1234EXPLAIN SELECT * FROM `mysql`.`proxies_priv` 查询结果如下 | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra || —- | ———– | ———— | ———- | —- | ————- | —- | ——- | —- | —- | ——– | —– || 1 | SIMPLE | proxies_priv | system | | | | | 1 | 100 | | | const 表中只有一行匹配的数据，在 where 条件中和所有 1)主键 2) 唯一键 进行比较时会用到 const 比如有如下表 12345678910CREATE TABLE `tb_name` ( `pp1` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL, `pp2` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL, `f3` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL, `f4` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL, UNIQUE KEY `pp1` (`pp1`,`pp2`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;INSERT INTO `db02`.`tb_name`(`pp1`, `pp2`, `f3`, `f4`) VALUES ('1', '2', '3', '4');INSERT INTO `db02`.`tb_name`(`pp1`, `pp2`, `f3`, `f4`) VALUES ('2', '3', '4', '5'); 执行如下查询 12345678910111213141516EXPLAIN SELECT * FROM `tb_name` WHERE pp1 = '1' AND pp2 = '2'## 或者EXPLAIN SELECT * FROM `tb_name` WHERE pp2 = '2' AND pp1 = '1'都会使用 const 结果如下 | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra || —- | ———– | ——- | ———- | —– | ————- | —- | ——- | ———– | —- | ——– | —– || 1 | SIMPLE | tb_name | | const | pp1 | pp1 | 2046 | const,const | 1 | 100 | | eq_ref 前表的每一行，在后表中只有一行被扫描 One row is read from this table for each combination of rows from the previous tables. 有如下两张表 123456789101112131415161718192021222324252627CREATE TABLE `students` ( `id` int(11) NOT NULL, `name` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL, `age` int(3) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;INSERT INTO `db02`.`students`(`id`, `name`, `age`) VALUES (1, '张三', 23);INSERT INTO `db02`.`students`(`id`, `name`, `age`) VALUES (2, '李四', 33);CREATE TABLE `scores` ( `user_id` int(11) NOT NULL, `score` int(255) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;\\INSERT INTO `db02`.`scores`(`user_id`, `score`) VALUES (1, 100);EXPLAIN SELECT * FROM students t1, scores t2 WHERE t1.id = t2.user_id 可见 scores 表中只有一条数据，结果如下， | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra || —- | ———– | —– | ———- | —— | ————- | ——- | ——- | ————— | —- | ——– | —– || 1 | SIMPLE | t2 | | ALL | PRIMARY | | | | 1 | 100 | || 1 | SIMPLE | t1 | | eq_ref | PRIMARY | PRIMARY | 4 | db02.t2.user_id | 1 | 100 | | 如果再往 score 表中 插入一行数据，则会变为全表扫描 ref 非唯一性索引扫描，返回匹配某个单独值的所有行. 这个索引 1) 不是 主键 也不是 唯一键 或者 2）使用最左匹配原则进行匹配 ref 虽然使用了索引，但是查询结果并不唯一，但是并不需要扫描全表，因为索引时有序的 有如下两个表 1234567891011121314151617181920212223242526272829303132333435CREATE TABLE `tb_ref` ( `f1` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL, `f2` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL, `f3` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL, `f4` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL, KEY `index_tb_ref_f1` (`f1`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;## 一定要多添 `tb_ref` 一定要多添加几条数据，如果数据太少 mysql 直接会使用全表扫描 type=ALLINSERT INTO `tb_ref`(`f1`, `f2`, `f3`, `f4`) VALUES ('1', '2', '3', '4');INSERT INTO `tb_ref`(`f1`, `f2`, `f3`, `f4`) VALUES ('2', '2', '3', '4');INSERT INTO `tb_ref`(`f1`, `f2`, `f3`, `f4`) VALUES ('2', '2', '3', '4');INSERT INTO `tb_ref`(`f1`, `f2`, `f3`, `f4`) VALUES ('2', '2', '3', '4');INSERT INTO `tb_ref`(`f1`, `f2`, `f3`, `f4`) VALUES ('2', '2', '3', '4');INSERT INTO `tb_ref`(`f1`, `f2`, `f3`, `f4`) VALUES ('2', '2', '3', '4');INSERT INTO `tb_ref`(`f1`, `f2`, `f3`, `f4`) VALUES ('2', '2', '3', '4');INSERT INTO `tb_ref`(`f1`, `f2`, `f3`, `f4`) VALUES ('2', '2', '3', '4');INSERT INTO `tb_ref`(`f1`, `f2`, `f3`, `f4`) VALUES ('2', '2', '3', '4');INSERT INTO `tb_ref`(`f1`, `f2`, `f3`, `f4`) VALUES ('2', '2', '3', '4');CREATE TABLE `other_table` ( `ref_f1` varchar(255) COLLATE utf8mb4_bin NOT NULL, `age` int(3) DEFAULT NULL, `name` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;INSERT INTO `other_table`(`ref_f1`, `age`, `name`) VALUES ('1', 22, '张三');INSERT INTO `other_table`(`ref_f1`, `age`, `name`) VALUES ('1', 23, '张1三');INSERT INTO `other_table`(`ref_f1`, `age`, `name`) VALUES ('2', 23, '张1三');INSERT INTO `other_table`(`ref_f1`, `age`, `name`) VALUES ('2', 23, '张1三');INSERT INTO `other_table`(`ref_f1`, `age`, `name`) VALUES ('2', 23, '张1三');INSERT INTO `other_table`(`ref_f1`, `age`, `name`) VALUES ('2', 23, '张1三');INSERT INTO `other_table`(`ref_f1`, `age`, `name`) VALUES ('2', 23, '张1三');INSERT INTO `other_table`(`ref_f1`, `age`, `name`) VALUES ('2', 23, '张1三');INSERT INTO `other_table`(`ref_f1`, `age`, `name`) VALUES ('2', 23, '张1三'); 执行如下语句 123456EXPLAIN SELECT * FROM tb_ref WHERE f1='1' 结果如下： | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra || —- | ———– | —— | ———- | —- | ————— | ————— | ——- | —– | —- | ——– | —– || 1 | SIMPLE | tb_ref | | ref | index_tb_ref_f1 | index_tb_ref_f1 | 1023 | const | 1 | 100 | | 执行如下语句 1234567EXPLAIN SELECT * FROM tb_ref t1, other_table t2 WHERE t1.f1 = t2.ref_f1 返回结果 id select_type table partitions type possible_keys key key_len ref rows filtered Extra 1 SIMPLE t2 ALL 9 100 1 SIMPLE t1 ref index_tb_ref_f1 index_tb_ref_f1 1023 db02.t2.ref_f1 1 100 range range 是范围扫描，当比较索引列包含 1=, &lt;&gt;, &gt;, &gt;=, &lt;,&lt;=, IS NULL, &lt;=&gt;, BETWEEN, LIKE, or IN() 时，可能产生 range Only rows that are in a given range are retrieved, using an index to select the rows. The key column in the output row indicates which index is used. The key_len contains the longest key part that was used. The ref column is NULL for this type. range can be used when a key column is compared to a constant using any of the =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, LIKE, or IN() operators: SELECT FROM tbl_name WHERE key_column = 10; SELECT FROM tbl_name WHERE key_column BETWEEN 10 and 20; SELECT FROM tbl_name 1351 EXPLAIN Output Format WHERE key_column IN (10,20,30); SELECT FROM tbl_name WHERE key_part1 = 10 AND key_part2 IN (10,20,30); 覆盖索引（covering index）理解方式一：就是select的数据列只从索引中就能取得，不必读取数据行，mysql可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，欢聚话说查询列要被所建的索引覆盖。 理解方式二：索引是高校找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取真个行，毕竟索引的叶子节点存储了它们索引的数据；当能通过读取索引你就可以得到想要的数据，那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫索引。 注意： 如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可 select *, 因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。 explan 分析执行顺序的例子来自尚硅谷的例子","link":"/2020/12/27/MysqlExplain%E7%9A%84type%E5%AD%97%E6%AE%B5/"},{"title":"Vue子组件向父组件传值","text":"我们的目的是 ：通过子组件传递值给父组件，改变父组件的属性值，并通过父组件改变另一个子组件的值 父组件的的代码如下 1234567891011121314151617181920212223242526&lt;template&gt; // 子组件绑定一个方法 changeTitle &lt;div id =&quot;appheader&quot; v-on:click=&quot;changeTitle&quot;&gt; &lt;h1&gt;{{this.title}}&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Header', data () { return { title:&quot;hello vue! nice to meet you &quot; } }, methods:{ // 这个方法将在父组件中寻找 titleChanged标记的元素 changeTitle:function(){ // 第二个参数是需要传递的新的title的值 this.$emit(&quot;titleChanged&quot;,&quot;子向父组件传值&quot;); } }}&lt;/script&gt; 父组件的代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; // 在这里注册了标记 将调用改变标题的方法 &lt;appheader v-on:titleChanged=&quot;updateTitle($event)&quot;&gt;&lt;/appheader&gt; // 在这里给另一个子组件也绑定了父组件的title &lt;appfooter v-bind:title=title&gt;&lt;/appfooter&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import appheader from './components/Header'import footer from './components/footer'export default { name: 'App', data() { return { title:&quot;这是我的第一个vue程序&quot;, theuser:[{name:&quot;zhangsan&quot;,position:&quot;java开发&quot;,show:false}, {name:&quot;zhangsan&quot;,position:&quot;java开发&quot;,show:false}, {name:&quot;zhangsan&quot;,position:&quot;java开发&quot;,show:false}, {name:&quot;zhangsan&quot;,position:&quot;java开发&quot;,show:false}], } }, components:{ &quot;appheader&quot;:appheader, &quot;appfooter&quot;:footer, }, methods:{ updateTitle(title){ this.title = title; } }}&lt;/script&gt;&lt;style&gt;h1 { color:red;}&lt;/style&gt; 另一个子组件，这个子组件的title也会改变 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;footer&gt; &lt;h1&gt;{{copyright}}&lt;/h1&gt; &lt;p&gt;{{title}}&lt;/p&gt;&lt;/footer&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'app-footer', props:[&quot;title&quot;], data () { return { copyright:&quot;copyright 2018 Vue Demo &quot; } }}&lt;/script&gt;&lt;style scoped &gt;footer { background: #222; padding: 6px;}h1 { color: lightgreen; text-align: center;}p{ color: lightgreen; text-align: center;}&lt;/style&gt; 演示效果点击之前 点击之后","link":"/2018/11/05/Vue%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"},{"title":"Vue父页面向子页面传值","text":"父页面通过v-bind 命令，将数据绑定在子页面调用时 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;rdgd&lt;/h1&gt; &lt;appheader&gt;&lt;/appheader&gt; // 在这里将数据绑定到子页面 &lt;users v-bind:theuser=&quot;theuser&quot;&gt;&lt;/users&gt; &lt;appfooter&gt;&lt;/appfooter&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Users from './components/Users';import appheader from './components/Header'import footer from './components/footer'export default { name: 'App', data(){ return { title:&quot;这是我的第一个vue程序&quot;, // 这是需要绑定的数据 theuser:[{name:&quot;zhangsan&quot;,position:&quot;java开发&quot;,show:false}, {name:&quot;zhangsan&quot;,position:&quot;java开发&quot;,show:false}, {name:&quot;zhangsan&quot;,position:&quot;java开发&quot;,show:false}, {name:&quot;zhangsan&quot;,position:&quot;java开发&quot;,show:false}] } }, // 这里不能使用 p div 等html元素名称 components:{ &quot;appheader&quot;:appheader, &quot;appfooter&quot;:footer, &quot;users&quot;:Users }}&lt;/script&gt; 子页面通过props属性访问 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;users&quot;&gt; &lt;h1&gt;Hello Users&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;user in theuser&quot; @click=&quot;user.show = !user.show&quot;&gt; &lt;h2&gt;{{user.name}}&lt;/h2&gt; &lt;h3 v-show=&quot;user.show&quot;&gt;{{user.position}}&lt;/h3&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'users', // 这种方法不推荐 // props:['theuser'], // 这是官方推荐的写法 props:{ theuser:{ type:Array, required:true } }, data () { return { } }}&lt;/script&gt;","link":"/2018/11/05/Vue%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%90%91%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC/"},{"title":"Vue组件嵌套","text":"全局注册在main.js中注册组件Users 12345678910111213141516import Vue from 'vue'import App from './App'Vue.config.productionTip = falseimport Users from './components/Users'// 全局注册组件Vue.component(&quot;users&quot;,Users)/* eslint-disable no-new */new Vue({ el: '#app', components: { App }, template: &quot;&lt;App/&gt;&quot;}) 局部注册在App.vue中注册 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; {{this.title}} &lt;users&gt;&lt;/users&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Users from './components/Users';export default { name: 'App', data(){ return { title:&quot;这是我的第一个vue程序&quot; } }, // 这里不能使用 p div 等html元素名称 components:{&quot;users&quot;:Users}}&lt;/script&gt;&lt;style&gt;&lt;/style&gt;","link":"/2018/11/05/Vue%E7%BB%84%E4%BB%B6%E5%B5%8C%E5%A5%97/"},{"title":"docker安装rabbitmq","text":"拉取 docker 镜像 这里使用的 网易云的镜像 1docker pull hub.c.163.com/library/rabbitmq:latest 启动容器 5762 是服务的端口，15762 是管理控制台的端口 1docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq hub.c.163.com/library/rabbitmq:latest 启动好后，访问 rabbitmq 的控制台，发现无法访问，需要开启管理插件 1http://ip:15762/ 进入 rabbitmq 的命令行 1docker exec -it rabbitmq bash 执行以下命令 1rabbitmq-plugins enable rabbitmq_management 再次访问 ip:15762 即可以正常访问控制台 初始用户名和密码是 guest guest","link":"/2019/11/03/docker%E5%AE%89%E8%A3%85rabbitmq/"},{"title":"docker尚硅谷","text":"Docker 解决了什么问题 运行环境不一致所带来的问题 隔离运行环境 docker 的标准化，让弹性伸缩变为可能","link":"/2019/08/22/docker%E5%B0%9A%E7%A1%85%E8%B0%B7/"},{"title":"fastdfs安装遇到的问题","text":"在安装 fastdfs 启动 nginx 遇到如下两个问题 12345[2019-10-18 09:44:00] ERROR - file: shared_func.c, line: 968, /etc/fdfs/mod_fastdfs.conf is not a regular file[2019-10-18 09:44:00] ERROR - file: /tmp/fastdfs-nginx-module/src/common.c, line: 155, load conf file &quot;/etc/fdfs/mod_fastdfs.conf&quot; fail, ret code: 222019/10/18 09:44:00 [alert] 29644#0: worker process 29991 exited with fatal code 2 and cannot be respawned2019/10/18 09:51:35 [notice] 30120#0: signal process started 解决方法： 1chmod 755 /etc/fdfs/ 在执行上面的命令后 还会遇到另一个问题 1234[2019-10-18 09:57:03] ERROR - file: shared_func.c, line: 979, open file /etc/fdfs/http.conf fail, errno: 13, error info: Permission denied[2019-10-18 09:57:03] ERROR - file: /tmp/fastdfs-nginx-module/src/common.c, line: 155, load conf file &quot;/etc/fdfs/mod_fastdfs.conf&quot; fail, ret code: 132019/10/18 09:57:03 [alert] 29644#0: worker process 30215 exited with fatal code 2 and cannot be respawned 解决方法 打开 nginx 的配置文件 将 1#user nobody; 改为 1user root;","link":"/2019/10/18/fastdfs%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"docker更改默认存储位置","text":"docker 容器默认安装在系统盘，一般情况下系统盘比较小，随着镜像和容器的不断增加，可能回出现容量不够的情况，所以需要手动指定 docker 相关文件的存储位置 编辑 /etc/docker/daemon.json 文件 1vi /etc/docker/daemon.json 增加相关配置 1234{ &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;], &quot;data-root&quot;: &quot;/www/docker&quot;} 其中 registry-mirror 指定镜像仓库的源 data-root 指定镜像和容器的存储路径 保存之后重启 docker 1systemctl restart docker","link":"/2022/06/09/docker%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/"},{"title":"git远程分支","text":"推送当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 - 你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。 如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push (remote) (branch): 12345678$ git push origin serverfixCounting objects: 24, done.Delta compression using up to 8 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.Total 24 (delta 2), reused 0 (delta 0)To https://github.com/schacon/simplegit * [new branch] serverfix -&gt; serverfix 这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分，但是现在可以先把它放在儿。 你也可以运行 git push origin serverfix:serverfix，它会做同样的事 - 相当于它说，“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。 下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用： 需要特别注意的是 可以通过 git push origin serverfix:awsomeserverfix 命令，将本地的 serverfix 分支的内容，推送到远程awsomeserverfix 分支上。 1234567$ git fetch originremote: Counting objects: 7, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From https://github.com/schacon/simplegit * [new branch] serverfix -&gt; origin/serverfix 要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支 - 只有一个不可以修改的 origin/serverfix 指针。 可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上： $ git checkout -b serverfix origin/serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch ‘serverfix’这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。 拉取当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。 由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。 删除远程分支1git push origin --delete serverfix 删除远程仓库的 serverfix 分支 默认跟踪分支下面的命令将本地的 ccc 分支与远程仓库 origin 的 nihao 分支建立跟踪关系 1git branch --set-upstream-to=origin/nihao ccc 如果不指定后面的 ccc 分支，则将当前所在分支与 origin/nihao 建立跟踪关系","link":"/2019/02/20/git%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/"},{"title":"git基础","text":"1. 撤销提交如果不小心运行了 git add * 把你不想跟踪的文件添加到了版本控制，使用如下命令撤销提交 123456789git reset HEAD &lt;File&gt;​````## 2.撤销对文件的修改如果修改了某个文件，但是想还原使用如下命令​```bashgit checkout -- &lt;file&gt; 3.查看远程仓库列表1git remote 3.添加远程仓库1git remote add &lt;shortname&gt; &lt;url&gt; 例如 123456$ git remote add pb https://github.com/paulboone/ticgit$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push)pb https://github.com/paulboone/ticgit (fetch)pb https://github.com/paulboone/ticgit (push) 4.将本地修改提交到远程服务器1git push &lt;remote&gt; &lt;branch&gt; 下面的命令的意思是 将本地 master 分支推送到 server 服务器上. 1git push origin master 5.了解远程仓库的详细信息1git remote show &lt;remotename&gt; 比如 12345678910111213$ git remote show origin* remote origin Fetch URL: git@github.com:lastdetective/myblogsourcecode.git Push URL: git@github.com:lastdetective/myblogsourcecode.git HEAD branch: master Remote branches: master tracked smallcomputer tracked Local branch configured for 'git pull': master merges with remote master Local refs configured for 'git push': master pushes to master (up to date) smallcomputer pushes to smallcomputer (up to date) 6.远程仓库的移除与重命名重命名 将远程仓库由 pb 重命名 为 paul 1git remote rename pb paul 移除paul 1git remote rm paul 7.直接添加和提交代码1git commit -a -m 'made a change' 8.直接新建和转换分支1git checkout -b hotfix 9. pull 命令1git pull origin master 这里的 master 是指远程的 master 分支 10. push 命令1git push origin master 将本地的 master 分支的数据，推送到它对应的 远程分支上去 这个远程分支可能是 awsomemaster 11.git 回退版本如果当前版本是 HEAD， 那么上一个版本就是 HEAD^，上上一个版本就是 HEAD^^ ，当然往上写100个 ^ 容易写不过来，所以写成 HEAD~100。我们要将当前版本回退到上一个版本，使用如下命令：1git reset --hard HEAD^如果我们知道版本号，还可以使用直接指定版本号 1git reset --hard s7s6d734 12.查看命令历史使用如下命令查看命令历史 1git reflog 结果如下 1234567$ git refloga993996 (HEAD -&gt; master) HEAD@{0}: reset: moving to a993996286b286 HEAD@{1}: reset: moving to HEAD^a993996 (HEAD -&gt; master) HEAD@{2}: commit: sss286b286 HEAD@{3}: commit: 我再次看看eee6a49 HEAD@{4}: commit: 让我看看是修改了哪一个83f7fe8 HEAD@{5}: commit (initial): 初次提交 13.比较命令不加参数，暂存区有文件未提交(commit)时，比较工作区和暂存区的文件 当暂存区的文件已经提交时，则比较工作区与最近一次提交的版本,如下比较名为 test1 的文件。 1git diff test1 如果同时你有一个分支叫做 test1 则以下命令 1git diff test1 则会出现如下的歧义 123fatal: ambiguous argument 'test1': both revision and filenameUse '--' to separate paths from revisions, like this:'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]' 这个时候需要制定版本号文件名 1git diff test1 -- test1 上面的命令比较当前分支工作区的 test1 文件 与 test1 分支上最新版本的 test1 文件 比较工作区与缓存区的文件 1git diff --cached 文件名 查看工作区和版本库里面最新版本的区别 1git diff HEAD 文件名 比较工作区与指定 commit-id 的区别 1git diff commit-id 文件名 比较两个 commit-id 之间的区别 1git diff [&lt;&gt;] 14.git分支查看分支 1git branch 创建分支 1git branch &lt;name&gt; 切换分支 1git checkout &lt;name&gt; 创建+切换分支 1git checkout -b &lt;name&gt; 删除分支 1git branch -d &lt;name&gt; 合并分支 1git merge &lt;name&gt; 15.git的标签打标签 1git tag &lt;tagname&gt; 指定标签信息 1git tag -a &lt;tagname&gt; -m 'bulabula' 查看所有的标签 1git tag 命令git push origin 可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。","link":"/2019/01/14/git%E5%9F%BA%E7%A1%80/"},{"title":"git问题处理","text":"Q1 fatal: remote origin already exists. 1git remote rm origin Q2取消文件跟踪 1git rm -r --cached [filename] Q3 fatal: refusing to merge unrelated histories 1git pull origin master --allow-unrelated-histories Q4git log查看分支图 1git log --oneline --decorate --graph --all Q5查看跟踪的文件 1git ls-files Q6Please move or remove them before you can merge 1git reset --hard HEAD","link":"/2018/12/23/git%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"title":"head first 设计模式读书笔记-观察者模式","text":"观察者模式需求有一个气象站，会随时更新气象信息。同时，有各种显示器，会展示这些气象信息。现在需要气象站每次更新数据时可以将新的数据及时推送到显示屏。 代码实现我们现在有一个 WeatherData（气象站）对象，负责产生新的天气数据，还有一个 CurrentConditionsDisplay（显示屏）对象，用来显示最新的气象数据，这个对象也就是观察者。观察者在气象站注册 (registerObserver) 之后，气象站如果有最新的数据就会及时提醒 ( notifyObservers ) 已经注册的观察者，及时更新显示。如果这个显示屏不想再接收到这个最新的气象数据，气象站可以将这个显示屏从气象站的通知列表中删除 ( removeObserver ) ，下次气象站有数据更新时，将不会通知这个显示屏。 定义一个借口，规定气象站应该有的功能 12345678910111213141516171819202122232425/** * 这个接口规定，气象站有哪些功能 */public interface Subject { /** * 注册观察者 * * @param observer */ void registerObserver(Observer observer); /** * 移除观察者 * * @param observer */ void removeObserver(Observer observer); /** * 通知观察者 */ void notifyObservers();} 实现一个气象站 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 定义这个气象站 */public class WeatherData implements Subject { /** * 注册的观察者列表 */ private ArrayList&lt;Observer&gt; observers; /** * 温度 */ private float temperature; /** * 湿度 */ private float humidity; /** * 气压 */ private float pressure; public WeatherData() { this.observers = new ArrayList&lt;&gt;(); } /** * 注册观察者 * * @param observer */ @Override public void registerObserver(Observer observer) { observers.add(observer); } /** * 移除观察者 * * @param observer */ @Override public void removeObserver(Observer observer) { observers.remove(observers.indexOf(observer)); } /** * 提醒观察者 */ @Override public void notifyObservers() { if (observers != null &amp;&amp; observers.size() &gt; 0) { observers.stream().forEach(o -&gt; o.update(temperature, humidity, pressure)); } } /** * 调用提醒方法 */ public void measurementsChanged() { notifyObservers(); } /** * 气象站设置新的数据，并通知观察者（显示屏） * * @param temperature * @param humidity * @param pressure */ public void setMeasurements(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); }} 定义两个接口，规定一个显示屏应该有的功能 12345678910111213/** * 规定观察者应该有更新自身数据的功能 */public interface Observer { void update(float temperature, float humidity, float pressure);}/** * 规定观察者应该有显示的功能 */public interface DisplayElement { void display();} 定义两个显示屏，分别显示现在的天气状况和明天的天气状况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 实时气温显示屏 */public class CurrentConditionsDisplay implements Observer, DisplayElement { private float temperature; private float humidity; private float pressure; WeatherData weatherData; /** * 每次生成一个显示屏，就向气象站注册 * * @param weatherData */ public CurrentConditionsDisplay(WeatherData weatherData) { this.weatherData = weatherData; weatherData.registerObserver(this); } @Override public void display() { System.out.println(&quot;现在的天气是: &quot; + temperature + &quot; ℃，相对湿度是： &quot; + humidity + &quot;%，大气压是：&quot; + pressure + &quot;kPa&quot;); } /** * 更新显示屏显示的数据 * * @param temperature * @param humidity * @param pressure */ @Override public void update(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; display(); }}/*** 天气预报显示屏*/public class ForecastDisplay implements Observer, DisplayElement { private float temperature; private float humidity; private float pressure; WeatherData weatherData; public ForecastDisplay(WeatherData weatherData) { this.weatherData = weatherData; weatherData.registerObserver(this); } @Override public void display() { System.out.println(&quot;现在的天气是: &quot; + temperature + &quot; ℃，相对湿度是： &quot; + humidity + &quot;%，大气压是：&quot; + pressure + &quot;kPa&quot;); } @Override public void update(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; display(); }} 代码测试 1234567891011121314151617181920public class WeatherStationTest { @Test public void runWeatherStation() { // 定义一个气象站 WeatherData weatherData = new WeatherData(); // 生成一个 实时温度 显示屏 CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData); // 生成一个 天气预报显示屏 ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData); // 气象站更新数据两个显示屏都会显示 weatherData.setMeasurements(25, 60, 101.3f); System.out.println(&quot;我现在只想看天气预报-----------&quot;); // 现在将实时气温显示屏移除，以后气象站更新数据，只会通知天气预报显示屏 weatherData.removeObserver(currentConditionsDisplay); weatherData.setMeasurements(26, 55, 101.4f); }} 运行效果 1234现在的天气是: 25.0 ℃，相对湿度是： 60.0%，大气压是：101.3kPa明天的天气是: 25.0 ℃，相对湿度是： 60.0%，大气压是：101.3kPa我现在只想看天气预报-----------明天的天气是: 26.0 ℃，相对湿度是： 55.0%，大气压是：101.4kPa 使用jdk自带的类来实现上述功能在 java.util 包中有两个类 Observable 和 Observer，可以帮助我们实现上面的功能 定义气象站的类 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Observable;public class WeatherData extends Observable { private float temperature; private float humidity; private float pressure; public WeatherData() { } /** * 调用提醒方法 */ public void measurementsChanged() { /* 设置 Observable 类中的 changed 属性为 true，只有当 changed 属性为 true 时， * notifyObservers 方法内部才会调用各个显示屏的update的方法 */ setChanged(); notifyObservers(); } public void setMeasurements(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); } public float getTemperature() { return temperature; } public float getHumidity() { return humidity; } public float getPressure() { return pressure; }} 定义两个显示屏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 当前气温显示屏 * DisplayElement 代码同上 */public class CurrentConditionsDisplay implements Observer, DisplayElement { Observable observable; private float temperature; private float humidity; private float pressure; // 构建一个显示屏时，向气象站注册 public CurrentConditionsDisplay(Observable observable) { this.observable = observable; observable.addObserver(this); } @Override public void display() { System.out.println(&quot;今天的天气是: &quot; + temperature + &quot; ℃，相对湿度是： &quot; + humidity + &quot;%，大气压是：&quot; + pressure + &quot;kPa&quot;); } @Override public void update(Observable o, Object arg) { if (o instanceof WeatherData) { WeatherData weatherData = (WeatherData) o; this.temperature = weatherData.getTemperature(); this.humidity = weatherData.getHumidity(); this.pressure = weatherData.getPressure(); display(); } }}import java.util.Observable;import java.util.Observer;/** * 天气预报显示屏 */public class ForecastDisplay implements Observer, DisplayElement { private float temperature; private float humidity; private float pressure; Observable observable; @Override public void display() { System.out.println(&quot;明天的天气是: &quot; + temperature + &quot; ℃，相对湿度是： &quot; + humidity + &quot;%，大气压是：&quot; + pressure + &quot;kPa&quot;); } public ForecastDisplay(Observable observable) { this.observable = observable; observable.addObserver(this); } @Override public void update(Observable o, Object arg) { if (o instanceof WeatherData) { WeatherData weatherData = (WeatherData) o; humidity = weatherData.getHumidity(); temperature = weatherData.getTemperature(); pressure = weatherData.getPressure(); display(); } }} 测试代码 12345678910111213141516public class WeatherStation { @Test public void runWeatherStation2() { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData); ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData); weatherData.setMeasurements(25, 60, 101.1f); System.out.println(&quot;------现在我们把当前温度移除--------&quot;); weatherData.deleteObserver(currentConditionsDisplay); weatherData.setMeasurements(32, 71, 101.6f); }} 运行结果 1234明天的天气是: 25.0 ℃，相对湿度是： 60.0%，大气压是：101.1kPa今天的天气是: 25.0 ℃，相对湿度是： 60.0%，大气压是：101.1kPa------现在我们把当前温度移除--------明天的天气是: 32.0 ℃，相对湿度是： 71.0%，大气压是：101.6kPa","link":"/2018/11/17/head-first-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"java in puzzles summary","text":"第二章 Expressive Puzzles第三章 with CharacterPuzzle 11 The Last Laugh执行下面的代码 123456public class LastLaugh { public static void main(String args[]) { System.out.print(&quot;H&quot; + &quot;a&quot;); System.out.print(’H’ + ’a’); }} 预期的打印结果是 1HaHa 但是实际情况如下 1Ha169 第二个打印语句实际上是将两个字符的ASCII码值相加的结果 下面的语句是可以将两个字符连起来的 12System.out.print(&quot;&quot;+'H' + 'a');// 输出Ha 下面的例子中 不会输出两个数字相加的结果，而是将数字相加的操作作为字符串打印出来 123System.out.println(&quot;2 + 2 = &quot; + 2+2);// 输出2 + 2 = 22显然我们期望的结果是 2 + 2 = 4 从 Java1.5 开始，下面的语句也可以将 两个 char ，作为字符串链接输出 1System.out.printf(&quot;%c%c&quot;, 'H', 'a'); 结论 the + operator performs string concatenation if and only if at least one of its operands is of type String; otherwise, it performs addition. 当且仅当运算符中的至少一个是字符串类型时，+ 运算符才执行字符串连接，在其他情况下执行加操作 如果需要进行字符串连接的几个值之间没有一个是 String 类型，那么有以下几个选择： 增加一个空字符串 &quot;&quot; 使用 String.valueOf() 进行显式转换； 使用 StringBuffer/StringBuilder 使用上面提到的 System.out.printf(&quot;%c%c&quot;, 'H', 'a');的写法 Puzzle12 ABC运行下面的代码 123String letters = &quot;ABC&quot;;char[] numbers = { '1', '2', '3' };System.out.println(letters + &quot; easy as &quot; + numbers); 预期输出 1ABC easy as 123 实际输出 1ABC easy as [C@5e2de80c 之所以会出现上面的结果是因为 在打印的时候 numbers 调用了 Object 的 toString 方法: 123public String toString() { return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); } 所以会导致 出现上面的字符串 为了解决上面的问题，可以调用 String.valueOf(char[] data) 方法，该方法会答应出字符数组内所有的字符: 123String letters = &quot;ABC&quot;;char[] numbers = {'1', '2', '3'};System.out.println(letters + &quot; easy as &quot; + String.valueOf(numbers)); 上面的代码输出 1ABC easy as 123 也可以使用下面的分开输出的方法 调用 println(char[] data) 方法: 1234String letters = &quot;ABC&quot;; char[] numbers = {'1', '2', '3'}; System.out.print(letters + &quot; easy as &quot;); System.out.println(numbers); 总结 char arrays are not strings. To convert a char array to astring, invoke String.valueOf(char[]) .char 数组不是字符串。 要将char数组转换为字符串，请调用String.valueOf（char []）。 Puzzle 14 Escape Rout这里实际上是使用 Unicode 标识 ASCII 字符 1System.out.println(&quot;a\\u0022.length() + \\u0022b&quot;.length()); 打印结果是 2 等同于 1System.out.println(&quot;a&quot;.length() + &quot;b&quot;.length()); 使用转义之后，即可打印字符串的长度 12System.out.println(&quot;a\\&quot;.length() + \\&quot;b&quot;.length());// 16 结论 In summary, prefer escape sequences to Unicode escapes in string and character literals. 总之，相对于字符串和字符文字中的Unicode转义，更喜欢转义序列。 Do not use Unicode escapes to represent ASCII characters. 不要使用Unicode转义符表示ASCII字符。 Puzzle 20 What’s My Class?下面的代码是将字符串中的所有点号转换成斜杠 12345public static void main(String[] args) { System.out.println(MyTest.class.getName()); System.out.println( MyTest.class.getName().replaceAll(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;); } 最后打印的结果是 12com.bruceliu.algorithms.puzzles.MyTest//////////////////////////////////////.class 出现这个结果的原因是 replaceAll()方法的第一个参数是一个正则表达式(regular expression)，而不是一个字符串序列 正则表达式“。” 匹配任何单个字符，因此类名的每个字符都用斜杠替换，产生我们看到的输出。 123456public static void main(String[] args) { System.out.println(MyTest.class.getName()); System.out.println( MyTest.class.getName().replaceAll(&quot;\\\\.&quot;, &quot;/&quot;) + &quot;.class&quot;);} 自 JAVA 1.5 开始，也可以使用以下代码 12System.out.println(MyTest.class.getName(). replaceAll(Pattern.quote(&quot;.&quot;), &quot;/&quot;) + &quot;.class&quot;); 要仅匹配句点字符，正则表达式中的句点必须通过在其前面加上反斜杠（\\）进行转义。 因为反斜杠字符在字符串文字中有特殊含义-它开始一个转义序列-后面的斜杠本身必须用第二个反斜杠转义。 Puzzle: 21执行下面的代码 1System.out.println(MeToo.class.getName().replaceAll(&quot;\\\\.&quot;, File.separator) + &quot;.class&quot;); 这段代码在 windows 平台会报错 File.separator 在 windows 平台是反斜杠 backslash,反斜杠会对其之后的字符进行转义。而在上面的例子中，反斜杠后面没有其他字符了，所以第二个参数是一个无效的输入。 自 java 1.5 之后有两种方法解决这个问题，方法一： 1System.out.println(MyTest.class.getName().replaceAll(&quot;\\\\.&quot;, Matcher.quoteReplacement(File.separator))+ &quot;.class&quot;); 方法二： 12System.out.println(MyTest.class.getName().replace(&quot;.&quot;, File.separator) + &quot;.class&quot;);注意 replace 方法的第一个参数是 字符序列 而不是正则表达式 在 java 1.5 之前同样也有解决方法 1System.out.println(MyTest.class.getName().replace('.', File.separatorChar) + &quot;.class&quot;); Puzzle: 23 No Pain，No Gain.1234567891011121314151617181920212223import java.util.Random;public class Rhymes { private static Random rnd = new Random(); public static void main(String[] args) { StringBuffer word = null; switch (rnd.nextInt(2)) { case 1: word = new StringBuffer(’P’); case 2: word = new StringBuffer(’G’); default: word = new StringBuffer(’M’); } word.append(’a’); word.append(’i’); word.append(’n’); System.out.println(word); }}上面代码的目的是 打印出 Pain,Gain或者Main但是运行结果是 只打印 `ain` 有如下三个bug rnd.nextInt(2) 的取值范围是[0,2)，2是永远不可能取到的，这里应该改成 rnd.nexInt(3); switch 语句没有 break，应该给每一个分支增加 break; new StringBuffer(char) 实际调用的是 new StringBuffer(int capacity),即给 StringBuffer 初始化大小，并不是 new StingBuffer(String str) 初始化字符串 可以进行如下的修改 123456789101112131415161718192021222324import java.util.Random;public class Rhymes { private static Random rnd = new Random(); public static void main(String[] args) { StringBuffer word = null; switch (rnd.nextInt(3)) { case 1: word = new StringBuffer(&quot;P&quot;); break; case 2: word = new StringBuffer(&quot;G&quot;); break; default: word = new StringBuffer(&quot;M&quot;); break; } word.append('a'); word.append('i'); word.append('n'); System.out.println(word); }} 这个代码还可以写得更加优雅 1System.out.println(&quot;PGM&quot;.charAt(rnd.nextInt(3)) + &quot;ain&quot;); 第四章 Loopy PuzzlersPuzzle 24: A Big Delight in Every Byte","link":"/2020/06/03/java-in-puzzles-summary/"},{"title":"java8tomap","text":"1234final Map&lt;String, JSONObject&gt; moudlesDataMap = allModulesData.stream() .collect(Collectors.toMap( item -&gt; (item.get(&quot;name&quot;).toString()), item -&gt; item, (oldValue, newValue) -&gt; newValue));","link":"/2020/08/11/java8tomap/"},{"title":"java8学习笔记","text":"Lambda 表达式三、Lambda 表达式5. 类型检查、类型推断以及限制使用局部变量Lambda 可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但是局部变量必须显式申明为 final， 或者事实上是final。 Variable used in lambda expression should be final or effectively final 例如下面的 代码是可以编译的 12int portNumber = 1337;Runnable r = () -&gt; System.out.println(portNumber); 上面的代码在 Lambda 中引用了局部变量 portNumber，虽然这个变量没有声明为 final ，但是在其声明赋初值之后，并没有试图去改变这个变量的值，所以这个变量事实上是 final 状态。 下面的代码不能通过编译 123int portNumber = 1337;Runnable r = () -&gt; System.out.println(portNumber);portNumber = 31337; 上面的代码在第三行试图修改 portNumber 的值，所以这个变量并不是事实上 final","link":"/2019/05/06/java8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"java位移操作","text":"","link":"/2019/11/27/java%E4%BD%8D%E7%A7%BB%E6%93%8D%E4%BD%9C/"},{"title":"javascript函数调用中的 call 和 apply 方法","text":"每个 javascript 函数都包含两个非继承而来的方法：apply() 和 call() 。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。首先，apply() 方法接收两个参数：一个是在其中运行函数的的作用域，另一个是参数数组。其中第二个参数可以是 Array 的实例，也可以是 arguments 对象。例如：123456789101112131415function sum(num1, num2) { return num1 + num2;}function callSum1(num1, num2) { return sum.apply(this, arguments);}function callSum2(num1, num2) { return sum.apply(this,[num1, num2]);}console.log(callSum1(10, 10));console.log(callSum2(10, 10))","link":"/2019/01/25/javascript%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84-call-%E5%92%8C-apply-%E6%96%B9%E6%B3%95/"},{"title":"javascript的apply和call方法，以及构造函数","text":"javascript 的每个函数都包含两个非继承而来的方法：apply() 和 call()。这两个方法都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。 apply() 函数首先，apply() 方法接收两个参数： 运行函数的作用域 ( this ) 的值。 参数数组，这个参数可以是 Array 的实例，也可以是 arguments 对象。 1234567891011121314function sum(num1, num2) { return num1 + num2;}function callSum1(num1, num2) { return sum.apply(this, arguments);}function callSum2(num1, num2) { return sum.apply(this,[num1, num2])}console.log(callSum1(10, 10)); // 20console.log(callSum2(10, 10)); // 20 上面的例子中， callSum1() 在执行 sum() 函数时传入了 this 作为 this 值（因为是在全局作用域中调用的，所以传入的就是 window 对象） 和 arguments 对象。而 callSum2 同样也调用了 sum() 函数，但它传入的是 this 和一个参数数组。这两个函数都会正常返回结果。 在严格模式下，未指定环境对象而调用函数，则 this 值不会转化为 window ，而是 undefined。 call() 函数call() 方法与 apply() 函数的作用相同，他们区别仅在于接收参数的方式不同。对于 call() 方法而言，第一个参数 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用 call 方法时，传递给函数的参数必须逐个列举出来。 12345678cafunction sum(num1, num2) { return num1 + num2;}function callSum(num1, num2) { return sum.call(this, num1, num2)}console.log(callSum(10, 10)); //20 对象的构造函数下面是 Person 的构造函数。 123456789101112function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function() { alert(this.name) ; };}var person = Person(&quot;Bill Gates&quot;, 65, 'Software Enginerr');var person1 = new Person('梅西', 29, 'football player'); 上面第一种调用方法是 javascript 普通函数的调用方法，这里的 Person() 就是一个普通的 javascirpt 函数，调用过程中 this 是window 对象，这里不会返回任何的对象，最后person 的值是 undefined。 第二种调用方法主要经历了一下 4 个步骤： 创建一个新对象，暂时命名为 person 。 将构造函数的作用域附给了新的对象（如果使用 call 方法来调用，也就是 Person.call(person,'梅西', 29, 'football player' )）。 执行构造函数中的代码。 返回新的对象。 查看运行过程，我们发现 this 指向新创建的的 person 对象。 任何函数，只要通过 new 操作符来调用，那就可以当做构造函数；而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样","link":"/2019/01/31/javascript%E7%9A%84apply%E5%92%8Ccall%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"title":"java初始化值","text":"在类的成员变量中，java的基本数据（此处包含 String）类型将会赋初值 Data Type Default Value (for fields) byte 0 short 0 int 0 long 0L float 0.0f double 0.0d char ‘\\u0000’ String (or any object) null boolean false 局部变量略有不同。编译器永远不会将默认值分配给未初始化的局部变量。如果您无法在声明它的地方初始化本地变量，请确保在尝试使用它之前为其分配一个值。访问未初始化的局部变量将导致编译时错误。 官方文档","link":"/2019/12/22/java%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC/"},{"title":"maven的依赖机制","text":"传递依赖关系（Transitive Dependencies）依赖调解（Dependency mediation）这个机制决定了当遇到多个版本作为依赖项时，将选择该 artifact 的哪个版本。maven 使用 最近定义（nearest definition）的机制，就是说，它在maven关系树中使用最接近项目的以来关系版本。可以通过在当前工程的 pom 文件中在确保某个依赖的版本。当在pom中指定了某个依赖的不同版本时，以先声明的依赖版本为准 （nearest definition）它在maven关系树中使用最接近项目的以来关系版本，考虑下面的依赖树 123456A├── B│ └── C│ └── D 2.0└── E └── D 1.0 定义了 A B C 三个模块，其中有两个依赖关系 A-&gt;B-&gt;C-&gt;D ,A-&gt;E-&gt;D,当构建 A时，使用的D是1.0 版本，因为 A-E-D这个依赖关系更短，如果要在构建A时强制使用D2.0版本，可以在A的依赖中明确指定 D2.0,依赖树如下图 12345678A ├── B │ └── C │ └── D 2.0 ├── E │ └── D 1.0 │ └── D 2.0 依赖域（Dependency Scope） compileThis is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated to dependent projects. providedThis is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope provided because the web container provides those classes. A dependency with this scope is added to the classpath used for compilation and test, but not the runtime classpath. It is not transitive. runtimeThis scope indicates that the dependency is not required for compilation, but is for execution. Maven includes a dependency with this scope in the runtime and test classpaths, but not the compile classpath. testThis scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases. This scope is not transitive. Typically this scope is used for test libraries such as JUnit and Mockito. It is also used for non-test libraries such as Apache Commons IO if those libraries are used in unit tests (src/test/java) but not in the model code (src/main/java). systemThis scope is similar to provided except that you have to provide the JAR which contains it explicitly. The artifact is always available and is not looked up in a repository. importThis scope is only supported on a dependency of type pom in the &lt;dependencyManagement&gt; section. It indicates the dependency is to be replaced with the effective list of dependencies in the specified POM’s &lt;dependencyManagement&gt; section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency. 在maven多模块项目中，为了保持模块间依赖的统一，常规做法是在parent model中，使用dependencyManagement预定义所有模块需要用到的dependency(依赖) ;) 123456789101112131415161718192021&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Feign是一种声明式、模板化的HTTP客户端:以HTTP接口的形式暴露自身服务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;${spring-cloud-starter-feign.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 支持面向方面的编程即AOP，包括spring-aop和AspectJ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;version&gt;${spring.boot.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;${aspectjrt.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; ;) 然后，子model根据实际需要引入parent中预定义的依赖 ;) 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ;) 好处： 1、依赖统一管理(parent中定义，需要变动dependency版本，只要修改一处即可)； 2、代码简洁(子model只需要指定groupId、artifactId即可) 3、dependencyManagement只会影响现有依赖的配置，但不会引入依赖，即子model不会继承parent中dependencyManagement所有预定义的depandency，只引入需要的依赖即可，简单说就是“按需引入依赖”或者“按需继承”；因此，在parent中严禁直接使用depandencys预定义依赖，坏处是子model会自动继承depandencys中所有预定义依赖； 但是，问题也出现了： 单继承：maven的继承跟java一样，单继承，也就是说子model中只能出现一个parent标签； parent模块中，dependencyManagement中预定义太多的依赖，造成pom文件过长，而且很乱； 如何让这些依赖可以分类并清晰的管理？ 问题解决：import scope依赖 如何使用： 1、maven2.9以上版本 2、将dependency分类，每一类建立单独的pom文件 3、在需要使用到这些依赖的子model中，使用dependencyManagement管理依赖，并import scope依赖 3、注意：scope=import只能用在dependencyManagement里面,且仅用于type=pom的dependency 示例： ;) 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;!-- 重要：版本号要和父模块中预定义的spring boot版本号保持一致 --&gt; &lt;version&gt;${spring.boot.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; ;) maven编译后，下载了pom文件，在maven的本地仓库下查看pom文件如下： 好处分析： 1、单一职责原则，根据依赖的分类，细化每一个单一职责的pom文件 2、解决单继承问题，通过import pom文件达到依赖的目的（典型的非继承模式），从而不用从父类中引用依赖 3、父模块的pom就会非常干净，容易维护","link":"/2020/08/31/maven%E7%9A%84%E4%BE%9D%E8%B5%96%E6%9C%BA%E5%88%B6/"},{"title":"mysql-groupby报错","text":"mysql groupBy问题12ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'xxx' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 解决办法一 查询 sql_mode 1select @@global.sql_mode; 结果如下 1ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 只需要将上面的 ONLY_FULL_GROUP_BY 去掉就行 使用如下语句 1set @@global.sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'; 这种方法存在的问题 在有些时候不生效 mysql重启之后配置失效 解决办法二打开 mysql配置文件 my.cnf,在最下面添加 12[mysqld]sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 使用这种方法会永久解决上面的报错问题 P.S. 如果 mysql 使用的是 docker 在进入容器内部 1docker exec -it my-mysql /bin/bash 之后可能出现没有 vi/vim 工具导致无法修改配置文件 在此情况下首先执行 1apt-get update 然后安装 vim 1apt-get install vim","link":"/2020/09/16/mysql-groupby%E6%8A%A5%E9%94%99/"},{"title":"mysql问题","text":"提示时区错误 具体报错如下 1The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time zone 有两种解决方法 a. 在数据库路径的后面增加时区配置选项 1url: jdbc:mysql://localhost:3306/sell?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8 b. 增加全局配置的选项 使用下面的语句查看当前的时区配置 1SHOW VARIABLES LIKE '%time_zone%' 输出结果如下 Variable_name Value system_time_zone time_zone SYSTEM 将时区设置为 +8 区 1SET GLOBAL time_zone = '+8:00'","link":"/2019/03/11/mysql%E9%97%AE%E9%A2%98/"},{"title":"rabbitmq进阶","text":"基础知识交换机（exchange）的属性 autodelete 当最后一个绑定到 Exchange 上的队列删除后，自动删除该 Exchange。 internal 当前Exchange 是否用于 RabbitMq 内部使用，默认为 false。 arguments 扩展参数，用于 AMQP 协议自制订化使用 消息如何保障 100 % 的投递成功什么是生产端的可靠性投递 保障消息成功发出。 保障MQ 节点的成功接收。 发送端到MQ节点的（Broker）确认应答。 完善的消息进行补偿机制。 解决方法 消息落库，对消息状态进行打标 发送消息时，将消息持久化到数据库，并设置一个状态，客户端会送应答之后进行状态变更。 消息的延迟投递，做二次确认，回调检查。 业务数据入库 发送业务消息，并生成二次检查的消息 消费端收到这个消息正确处理之后，再生成一条消息，该消息由 call-back 进行监听，callback将其入库 生产段 经过几分钟之后 发送二次检查消息到 call-back，查看刚才的业务是否处理成功，如果成功则不进行任何操作，如果失败 call-back 会发起一个 rpc 请求，让生产端进行重发。 幂等性的概念可以借鉴数据库乐观锁的机制 比如执行如下的一条sql 1update t_reps set count = count-1,version=version+1 where id='xiaomi9' 如果现在某个手机在数据库中 count=1, 而且 version=1,在执行上面的 sql 的时候，应该首先查询数据库,多个进程应该查询数据库 1select count,version from t_reps where id ='xiaomi9'; 多个消费者进程可能都会查到这条数据，假设 count = 1, version=1 将上面的 sql 更改为 1update t_reps set count = count-1,version=version+1 where id='xiaomi9' and version = 1 可以避免多个进程的重复操作。 消费端-幂等性保障 唯一id+指纹码 机制 唯一id + 指纹码机制，利用数据库主键去重 1select count(*) from t_order where id = 唯一id+指纹码 好处 实现简单 坏处 高并发下有数据库写入的性能瓶颈 解决方案 数据库路由 使用 redis 的原子性特性 redis 进行幂等，需要考虑的问题： 我们是否要进行数据的落库，如果落库的话，关键问题是数据库和缓存如何做到原子性 如果不进行落库，那么都存储到缓存中，如何设置定时的同步策略。","link":"/2019/12/07/rabbitmq%E8%BF%9B%E9%98%B6/"},{"title":"redis基础","text":"redis 简介redis 是高性能键值对数据库，支持键值数据类型： 字符串类型 列表类型 有序集合类 散列类型 集合类型 redis 的应用场景 缓存 任务队列 应用排行榜 网站访问统计 数据过期处理 分布式集群架构中的 session 分离 redis 五种数据类型 字符串(String) 哈希(hash) 字符串列表(list) 字符串集合(set) 有序字符串集合(sorted set) 存储 String 二进制安全的，存入和获取的数据相同。 Value 最多可以容纳的数据长度是 512M redis 基本操作String 类型Hash 类型存入键值对, 将 username:jack 存入 myhash 中 12hset myhash username jackhset myhash age 20 一次存入多个键值对 1hmset myhash2 username rose age 21 根据键获取值 1hget myhash username 返回 1&quot;jack&quot; 根据多个键获取值 1hmget myhash2 username age 返回 121) &quot;rose&quot;2) &quot;21&quot; 获取所有键值对 1hgetall myhash 删除某个键值对 1hdel myhash2 username age 返回 12341) &quot;username&quot;2) &quot;jack&quot;3) &quot;age&quot;4) &quot;20&quot; 对某个数字进行增加:将 age 属性递增5。 1hincrby myhash2 age 5 返回 1(integer) 26 rose 的 age 属性由 21 增加到 26 判断某个set中是否含有某个键 1hexists myhash username 获取 hash 中的所有键 1hkeys myhash 运行结果为： 121) &quot;username&quot;2) &quot;age&quot; 获取 hash 中的所有值 1hvals myhash 运行结果为 121) &quot;jack&quot;2) &quot;20&quot; List 类型往 list 中存储数据（从左侧添加，先进去的数据排在最后一位） 12lpush mylist a b clpush mylist 1 2 3 从右侧添加 （从右侧添加） 12rpush mylist2 a b crpush mylist2 a b c 查看列表 表示从第一个到第六个元素 1lrange 0 5 运行结果如下 1234561) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;4) &quot;c&quot;5) &quot;b&quot;6) &quot;a&quot; 1lrange mylist2 0 -1 表示从第一个到倒数第一个元素 运行结果如下 1234561) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;1&quot;5) &quot;2&quot;6) &quot;3&quot; 左边弹出 1lpop mylist 运行结果 1&quot;3&quot; 右边弹出 1rpop mylist2 运行结果 1&quot;3&quot; lpushx 和 rpushx 仅当需要操作的 list 中有值时才进行保存操作 现在 mylist3 的数据如下 1234567891011 1) &quot;5&quot; 2) &quot;3&quot; 3) &quot;2&quot; 4) &quot;3&quot; 5) &quot;7&quot; 6) &quot;6&quot; 7) &quot;3&quot; 8) &quot;5&quot; 9) &quot;4&quot;10) &quot;2&quot;11) &quot;1&quot; 移除命令 lrem 从左侧开始删除两个3 1lrem mylist3 2 3 运行后的 mylist3 结果 1234567891) &quot;5&quot;2) &quot;2&quot;3) &quot;7&quot;4) &quot;6&quot;5) &quot;3&quot;6) &quot;5&quot;7) &quot;4&quot;8) &quot;2&quot;9) &quot;1&quot; 从后边往前删除两个1 1lrem mylist3 -2 1 运行后的 mylist3 结果 123456781) &quot;5&quot;2) &quot;2&quot;3) &quot;7&quot;4) &quot;6&quot;5) &quot;3&quot;6) &quot;5&quot;7) &quot;4&quot;8) &quot;2&quot; 删除所有2 1lrem mylist3 0 2 运行后的 mylist3 结果 1234561) &quot;5&quot;2) &quot;7&quot;3) &quot;6&quot;4) &quot;3&quot;5) &quot;5&quot;6) &quot;4&quot; 给某个指定的角标位置的元素设置值 1lset mylist 3 haha 运行结果如下 1234567891011121314127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;2&quot;2) &quot;1&quot;3) &quot;c&quot;4) &quot;b&quot;5) &quot;a&quot;127.0.0.1:6379&gt; lset mylist 3 hahaOK127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;2&quot;2) &quot;1&quot;3) &quot;c&quot;4) &quot;haha&quot;5) &quot;a&quot; 新建一个 list 12345678910127.0.0.1:6379&gt; lrange mylist4 0 -11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;4) &quot;c&quot;5) &quot;b&quot;6) &quot;a&quot;7) &quot;c&quot;8) &quot;b&quot;9) &quot;a&quot; 在第一个 b 之前插入 11 12345678910111213127.0.0.1:6379&gt; LINSERT mylist4 before b 11(integer) 10127.0.0.1:6379&gt; lrange mylist4 0 -1 1) &quot;c&quot; 2) &quot;11&quot; 3) &quot;b&quot; 4) &quot;a&quot; 5) &quot;c&quot; 6) &quot;b&quot; 7) &quot;a&quot; 8) &quot;c&quot; 9) &quot;b&quot;10) &quot;a&quot; 在第一个 b 之后插入 22 1234567891011121314127.0.0.1:6379&gt; LINSERT mylist4 after b 22(integer) 11127.0.0.1:6379&gt; lrange mylist4 0 -1 1) &quot;c&quot; 2) &quot;11&quot; 3) &quot;b&quot; 4) &quot;22&quot; 5) &quot;a&quot; 6) &quot;c&quot; 7) &quot;b&quot; 8) &quot;a&quot; 9) &quot;c&quot;10) &quot;b&quot;11) &quot;a&quot; 创建两个 list 12345678127.0.0.1:6379&gt; lrange mylist5 0 -11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;127.0.0.1:6379&gt; lrange mylist6 0 -11) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot; 现在讲 mylist5 右左边弹出，从左侧压入 mylist6 rpop 和 lpush 用于消息队列 12345678910127.0.0.1:6379&gt; RPOPLPUSH mylist5 mylist6&quot;a&quot;127.0.0.1:6379&gt; lrange mylist5 0 -11) &quot;c&quot;2) &quot;b&quot;127.0.0.1:6379&gt; lrange mylist6 0 -11) &quot;a&quot;2) &quot;3&quot;3) &quot;2&quot;4) &quot;1&quot; Set 类型set 类型不允许出现相同的操作，set 通常用作 跟踪一些唯一性数据 用户维护数据对象之间的关联关系 创建一个 set 并添加一个元素 123sadd myset asadd myset 1 2 3sadd myset 1 2 查看所有元素发现没有重复元素 12345127.0.0.1:6379&gt; SMEMBERS myset1) &quot;3&quot;2) &quot;1&quot;3) &quot;a&quot;4) &quot;2&quot; 查看一个元素是否存在于某个集合 1234127.0.0.1:6379&gt; SISMEMBER myset a(integer) 1127.0.0.1:6379&gt; SISMEMBER myset x(integer) 0 说明 myset 中包含 a，但不包含 x 创建两个 set 123456789127.0.0.1:6379&gt; SMEMBERS mya11) &quot;b&quot;2) &quot;c&quot;3) &quot;a&quot;127.0.0.1:6379&gt; SMEMBERS myb11) &quot;2&quot;2) &quot;1&quot;3) &quot;c&quot;4) &quot;a&quot; 找出 mya1 中有，但是 myb1 中没有的元素 12127.0.0.1:6379&gt; sdiff mya1 myb11) &quot;b&quot; 找出 myb1 中有，但是 mya1 中没有的元素 123127.0.0.1:6379&gt; sdiff myb1 mya11) &quot;1&quot;2) &quot;2 将 sdiff 产生的结果直接保存 1234127.0.0.1:6379&gt; SDIFFSTORE my1 mya1 myb1(integer) 1127.0.0.1:6379&gt; SMEMBERS my11) &quot;b&quot; 找出 mya1 ,myb1 中都有的元素 123127.0.0.1:6379&gt; SINTER mya1 myb11) &quot;c&quot;2) &quot;a&quot; 将上面的结果直接存储 12345127.0.0.1:6379&gt; SINTERSTORE my2 mya1 myb1(integer) 2127.0.0.1:6379&gt; SMEMBERS my21) &quot;a&quot;2) &quot;c&quot; 列出 mya1 和 myb1 的所有元素 123456127.0.0.1:6379&gt; SUNION mya1 myb11) &quot;b&quot;2) &quot;c&quot;3) &quot;2&quot;4) &quot;a&quot;5) &quot;1&quot; 将上面的结果直接保存 12345678127.0.0.1:6379&gt; SUNIONSTORE my3 mya1 myb1(integer) 5127.0.0.1:6379&gt; SMEMBERS my31) &quot;b&quot;2) &quot;c&quot;3) &quot;2&quot;4) &quot;a&quot;5) &quot;1&quot; 查看 set 中元素的个数 12127.0.0.1:6379&gt; SCARD mya1(integer) 3 随机返回 set 中的一个元素 123456127.0.0.1:6379&gt; SRANDMEMBER mya1&quot;b&quot;127.0.0.1:6379&gt; SRANDMEMBER mya1&quot;a&quot;127.0.0.1:6379&gt; SRANDMEMBER mya1&quot;c&quot; sorted setsorted set 中每一个元素都有一个分数与之关联，redis 正是通过这些分数来为 set 排序，sorted set 元素是有序的. 可以用于： 大型游戏的积分排行榜 构建索引数据 添加元素 1234567127.0.0.1:6379&gt; ZADD mysort 70 zs 80 ls 90 ww(integer) 3// 如果 set 中已经包将要添加的元素，执行添加命令将覆盖原来的分数 127.0.0.1:6379&gt; ZADD mysort 100 zs(integer) 0127.0.0.1:6379&gt; ZADD mysort 60 tom(integer) 1 展示元素的分数 12127.0.0.1:6379&gt; ZSCORE mysort zs&quot;100&quot; 移除元素 12127.0.0.1:6379&gt; zrem mysort tom ww(integer) 2 查看元素的个数 12127.0.0.1:6379&gt; ZCARD mysort(integer) 2 再添加两个元素 12127.0.0.1:6379&gt; zadd mysort 85 jack 95 rose(integer) 2 展示所有元素 12345127.0.0.1:6379&gt; ZRANGE mysort 0 -11) &quot;ls&quot;2) &quot;jack&quot;3) &quot;rose&quot;4) &quot;zs&quot; 展示所有元素和分数 123456789127.0.0.1:6379&gt; ZRANGE mysort 0 -1 withscores1) &quot;ls&quot;2) &quot;80&quot;3) &quot;jack&quot;4) &quot;85&quot;5) &quot;rose&quot;6) &quot;95&quot;7) &quot;zs&quot;8) &quot;100&quot; 按分数从大到小排列 123456789127.0.0.1:6379&gt; ZREVRANGE mysort 0 -1 withscores1) &quot;zs&quot;2) &quot;100&quot;3) &quot;rose&quot;4) &quot;95&quot;5) &quot;jack&quot;6) &quot;85&quot;7) &quot;ls&quot;8) &quot;80&quot; 删除排序从 0 到 3 的元素 123456789101112127.0.0.1:6379&gt; ZRANGE mysort 0 -11) &quot;bruce&quot;2) &quot;perter&quot;3) &quot;clark&quot;4) &quot;arrow&quot;5) &quot;wonder&quot;// 删除了排名 0 到 2 的元素127.0.0.1:6379&gt; ZREMRANGEBYRANK mysort 0 2(integer) 3127.0.0.1:6379&gt; ZRANGE mysort 0 -11) &quot;arrow&quot;2) &quot;wonder&quot; 新增几个元素 1234567891011127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;arrow&quot; 2) &quot;40&quot; 3) &quot;wonder&quot; 4) &quot;50&quot; 5) &quot;bruce&quot; 6) &quot;60&quot; 7) &quot;clark&quot; 8) &quot;70&quot; 9) &quot;peter&quot;10) &quot;80&quot; 查找分数在 40 到 70 分区间的前两个元素 12345127.0.0.1:6379&gt; ZRANGEBYSCORE mysort 40 70 withscores limit 0 21) &quot;arrow&quot;2) &quot;40&quot;3) &quot;wonder&quot;4) &quot;50&quot; 增加分数 12127.0.0.1:6379&gt; ZINCRBY mysort 7 arrow&quot;47&quot; 查找某个分数段内元素的个数 12127.0.0.1:6379&gt; ZCOUNT mysort 50 80(integer) 4 redis的keys基本操作 查找所有的 keys 123456127.0.0.1:6379&gt; keys * 1) &quot;myhash2&quot; 2) &quot;hahaha&quot; 3) &quot;mylist2&quot; 4) &quot;myhashset2&quot;... 查看以 my 开头的所有的 key 1234127.0.0.1:6379&gt; keys my?1) &quot;my3&quot;2) &quot;my2&quot;3) &quot;my1&quot; 删除 keys 12127.0.0.1:6379&gt; del my1 my2 my3(integer) 3 判断某个 key 是否存在 1234127.0.0.1:6379&gt; EXISTS hahahs(integer) 0127.0.0.1:6379&gt; EXISTS mysort(integer) 1 重命名key 123456789101112127.0.0.1:6379&gt; get compnay&quot;immooc&quot;127.0.0.1:6379&gt; RENAME compnay(error) ERR wrong number of arguments for 'rename' command127.0.0.1:6379&gt; RENAME compnay newcompanyOK// 重命名之后就获取不到了127.0.0.1:6379&gt; get compnay(nil)// 使用新的名字获取127.0.0.1:6379&gt; get newcompany&quot;immooc&quot; 设置超时时间 单位秒 12345127.0.0.1:6379&gt; EXPIRE newcompany 1000(integer) 1// 查看剩余超时时间127.0.0.1:6379&gt; ttl newcompany(integer) 989 查看 key 的类型 12345678910127.0.0.1:6379&gt; type newcompanystring127.0.0.1:6379&gt; type mylistlist127.0.0.1:6379&gt; type myhashhash127.0.0.1:6379&gt; type mysortzset127.0.0.1:6379&gt; type mysetset redis 的事务一个 redis 实例可以包含 15 个数据库，下标是从 0-15，默认选择第 0 号数据库 切换数据库命令如下 1234127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; keys *(empty list or set) 可以看到 1 号数据库中没有保存任何的key 将 0 号数据库中的一个 key 移动到 1 号数据库 123456127.0.0.1:6379&gt; MOVE mysort 1(integer) 1127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; keys *1) &quot;mysort&quot; multi 相当于开启事务 开启事务后，输入的命令将被保存的队列中 exec 相当于 commit 123456789101112127.0.0.1:6379&gt; get num&quot;65&quot;127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr numQUEUED127.0.0.1:6379&gt; incr numQUEUED127.0.0.1:6379&gt; exec1) (integer) 662) (integer) 67127.0.0.1:6379&gt; 执行之后命令队列中的命令将会被全部执行 discard 相当于 rollerback redis 持久化概述redis 之所以效率很高是因为数据都保存在内存中，为了使 redis 重启之后数据不丢失，就需要将 redis 数据保存到硬盘上。 redis 持久化有两种方式： RDB 方式 AOF 方式 持久化的使用方式 RDB 持久化：定期保存 redis 的快照到硬盘 AOF 通过日志记录 redis 的命令，每次重启之后读取这个文件来重现 redis 之前的状态 无持久化：单纯将 redis 作为一个缓存服务 同时使用 RDB 和 AOF RDB 方式在 redis.conf 文件中可以指定保存快照的时机 123save 900 1save 300 10save 60 10000 AOF 方式 需要在 redis.conf 中打开配置 12345678910# aof 是否打开 默认是关闭的 需要改为 yesappendonly yesappendfilename &quot;appendonly.aof&quot;# 每次操作都同步日志# appendfsync always# 每秒同步记录一次appendfsync everysec# 不同步# appendfsync no SringBoot Redis 重要注解Spring-boot 引入 redis 缓存机制，首先需要在启动类上增加一个注解 1@EnableCaching 在 controller 的方法上增加 @Cacheable 注解，一般用于查询接口 @Cacheable(cacheNames = &quot;product&quot;, key = '#sellerId', condition=&quot;#sellerId.length&gt;3&quot;, unless = &quot;#result.getCode()!=0&quot;) #sellerId 的写法成为 spel 表达式，获取参数 sellerId的值 当 sellerId 的字符长度大于 3 ，而且 除了 返回的 code!=0（也就是等于0都缓存） 当数据改变之后表用 @Cacheput 注解修改缓存，通常用于保存或者修改方法 @CachePut 要使用上面两个注解更新缓存 必须保证方法的返回值一致 如果上面两个注解的 key 不填或者为空，则key默认为方法的参数，这就会导致 key不一致的问题（即使方法的返回值一致） 可以把 cacheName 属性移到 类注解 @CacheConfig(cacheNames=&quot;product&quot;) @CacheEvict（cacheNames = &quot;product&quot;，key=&quot;123&quot;） 清除缓存 使用上面的缓存必须实现序列化","link":"/2019/03/17/redis%E5%9F%BA%E7%A1%80/"},{"title":"shell命令总结","text":"1sed -i '/master/a\\config' test 在匹配到 master 字符串的那一行的下一行 插入 config","link":"/2023/03/15/shell%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"title":"spring-cloud基础","text":"服务端发现的两种方式 客户端发现：Eureka 客户端发现：Nginx, Zookeeper, Kubernetes","link":"/2019/03/18/spring-cloud%E5%9F%BA%E7%A1%80/"},{"title":"spring-security基础","text":"一、简介构建系统时，对于请求需要考虑安全性的问题，可能需要进行身份验证、权限管理，这样可以有效保证自己网站的安全。 二、使用1. 安装引入 Spring Security 的依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;","link":"/2019/05/09/spring-security%E5%9F%BA%E7%A1%80/"},{"title":"springboot2.0深度实践","text":"核心特性Spring Boot 三大特性 组件自动装配：Web Mvc、Web Flux、JDBC 嵌入式WEB容器：Tomcat、Jetty 以及 Undertow 生产准备特性：指标、健康检查、外部化配置 Spring Boot Bean 源码解读1234567891011121314151617public class SpringApplicationBootstrap { public static void main(String[] args) { // 在 run 方法中可以填入带有 @SpringBootApplication 的注解的类 // SpringApplication.run(ApplicationTest.class, args); // 引导类的配置 Set&lt;String&gt; sources = new HashSet&lt;&gt;(); sources.add(ApplicationTest.class.getName()); SpringApplication springApplication = new SpringApplication(); springApplication.setSources(sources); ConfigurableApplicationContext context = springApplication.run(args); System.out.println(&quot;Bean &quot;+context.getBean(ApplicationTest.class)); } @SpringBootApplication public static class ApplicationTest{ }} Spring 可以通断出当前应用的类型，主要是在 SpringApplication 中的 org.springframework.boot.SpringApplication#setApplicationContextClass 方法中","link":"/2019/03/29/springboot2-0%E6%B7%B1%E5%BA%A6%E5%AE%9E%E8%B7%B5/"},{"title":"tomcat配置虚拟目录","text":"项目中的文件我们经常会存储在其他的文件夹，而不是数据库，而 tomcat 服务器可以将 文件的相对路径映射为文件的绝对路径","link":"/2019/02/01/tomcat%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95/"},{"title":"spring跨域配置","text":"以下内容来源于 spring 官方网站 https://spring.io/blog/2015/06/08/cors-support-in-spring-framework CORS support in Spring Frameworkhttps://spring.io/blog/2015/06/08/cors-support-in-spring-framework#disqus_thread) For security reasons, browsers prohibit AJAX calls to resources residing outside the current origin. For example, as you’re checking your bank account in one tab, you could have the evil.com website in another tab. The scripts from evil.com shouldn’t be able to make AJAX requests to your bank API (withdrawing money from your account!) using your credentials. Cross-origin resource sharing (CORS) is a W3C specification implemented by most browsers that allows you to specify in a flexible way what kind of cross domain requests are authorized, instead of using some less secured and less powerful hacks like IFrame or JSONP. Spring Framework 4.2 GA provides first class support for CORS out-of-the-box, giving you an easier and more powerful way to configure it than typical filter based solutions. Spring MVC provides high-level configuration facilities, described bellow. Controller method CORS configurationYou can add to your @RequestMapping annotated handler method a @CrossOrigin annotation in order to enable CORS on it (by default @CrossOrigin allows all origins and the HTTP methods specified in the @RequestMapping annotation): 123456789101112131415@RestController@RequestMapping(&quot;/account&quot;)public class AccountController { @CrossOrigin @GetMapping(&quot;/{id}&quot;) public Account retrieve(@PathVariable Long id) { // ... } @DeleteMapping(&quot;/{id}&quot;) public void remove(@PathVariable Long id) { // ... }} It is also possible to enable CORS for the whole controller: 123456789101112131415@CrossOrigin(origins = &quot;http://domain2.com&quot;, maxAge = 3600)@RestController@RequestMapping(&quot;/account&quot;)public class AccountController { @GetMapping(&quot;/{id}&quot;) public Account retrieve(@PathVariable Long id) { // ... } @DeleteMapping(&quot;/{id}&quot;) public void remove(@PathVariable Long id) { // ... }} In this example CORS support is enabled for both retrieve() and remove() handler methods, and you can also see how you can customize the CORS configuration using @CrossOrigin attributes. You can even use both controller and method level CORS configurations, Spring will then combine both annotation attributes to create a merged CORS configuration. 12345678910111213141516@CrossOrigin(maxAge = 3600)@RestController@RequestMapping(&quot;/account&quot;)public class AccountController { @CrossOrigin(origins = &quot;http://domain2.com&quot;) @GetMapping(&quot;/{id}&quot;) public Account retrieve(@PathVariable Long id) { // ... } @DeleteMapping(&quot;/{id}&quot;) public void remove(@PathVariable Long id) { // ... }} If you are using Spring Security, make sure to enable CORS at Spring Security level as well to allow it to leverage the configuration defined at Spring MVC level. 12345678@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.cors().and()... }} Global CORS configurationIn addition to fine-grained, annotation-based configuration you’ll probably want to define some global CORS configuration as well. This is similar to using filters but can be declared withing Spring MVC and combined with fine-grained @CrossOrigin configuration. By default all origins and GET, HEAD and POST methods are allowed. JavaConfigEnabling CORS for the whole application is as simple as: 123456789@Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;); }} If you are using Spring Boot, it is recommended to just declare a WebMvcConfigurer bean as following: 12345678910111213@Configurationpublic class MyConfiguration { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurerAdapter() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;); } }; }}COPY You can easily change any properties, as well as only apply this CORS configuration to a specific path pattern: 123456789@Overridepublic void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/api/**&quot;) .allowedOrigins(&quot;http://domain2.com&quot;) .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;) .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;) .exposedHeaders(&quot;header1&quot;, &quot;header2&quot;) .allowCredentials(false).maxAge(3600);} If you are using Spring Security, make sure to enable CORS at Spring Security level as well to allow it to leverage the configuration defined at Spring MVC level. XML namespaceIt is also possible to configure CORS with the mvc XML namespace. This minimal XML configuration enable CORS on /** path pattern with the same default properties than the JavaConfig one: 123&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt;&lt;/mvc:cors&gt;COPY It is also possible to declare several CORS mappings with customized properties: 12345678910111213&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/api/**&quot; allowed-origins=&quot;http://domain1.com, http://domain2.com&quot; allowed-methods=&quot;GET, PUT&quot; allowed-headers=&quot;header1, header2, header3&quot; exposed-headers=&quot;header1, header2&quot; allow-credentials=&quot;false&quot; max-age=&quot;123&quot; /&gt; &lt;mvc:mapping path=&quot;/resources/**&quot; allowed-origins=&quot;http://domain1.com&quot; /&gt;&lt;/mvc:cors&gt; If you are using Spring Security, don’t forget to enable CORS at Spring Security level as well: 12345&lt;http&gt; &lt;!-- Default to Spring MVC's CORS configuration --&gt; &lt;cors /&gt; ...&lt;/http&gt; How does it work?CORS requests (including preflight ones with an OPTIONS method) are automatically dispatched to the various HandlerMappings registered. They handle CORS preflight requests and intercept CORS simple and actual requests thanks to a CorsProcessor implementation (DefaultCorsProcessor by default) in order to add the relevant CORS response headers (like Access-Control-Allow-Origin). CorsConfiguration allows you to specify how the CORS requests should be processed: allowed origins, headers, methods, etc. It can be provided in various ways: AbstractHandlerMapping#setCorsConfiguration() allows to specify a Map with several CorsConfiguration mapped on path patterns like /api/** Subclasses can provide their own CorsConfiguration by overriding AbstractHandlerMapping#getCorsConfiguration(Object, HttpServletRequest) method Handlers can implement CorsConfigurationSource interface (like ResourceHttpRequestHandler now does) in order to provide a CorsConfiguration for each request. Filter based CORS supportAs an alternative to other methods presented above, Spring Framework also provides a CorsFilter. In that case, instead of using @CrossOrigin or WebMvcConfigurer#addCorsMappings(CorsRegistry), you can for example declare the filter as following in your Spring Boot application: 1234567891011121314151617@Configurationpublic class MyConfiguration { @Bean public FilterRegistrationBean corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin(&quot;http://domain1.com&quot;); config.addAllowedHeader(&quot;*&quot;); config.addAllowedMethod(&quot;*&quot;); source.registerCorsConfiguration(&quot;/**&quot;, config); FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source)); bean.setOrder(0); return bean; }}","link":"/2020/06/30/spring%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/"},{"title":"vscode使用技巧","text":"1.打开 markdown 实时预览窗口在命令行中输入open locked preview to the side","link":"/2019/01/15/vscode%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"title":"vue-vuerouter-basic","text":"VueRouter Basic一个vuerouter的例子,这里引入了vue，vue-router，app.js需要自己编写 123456789101112131415&lt;!DOCTYPE &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;basic&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;script src=&quot;../vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../vue-router.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; app.js 文件内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 1.定义几个componentconst Home = { template: `&lt;div&gt;home&lt;/div&gt;`}const Foo = { template: '&lt;div&gt;foo&lt;/div&gt;'}const Bar = { template: `&lt;div&gt;bar&lt;/div&gt;`}const Unicoede = { template: `&lt;div&gt;unicode&lt;/div&gt;`}// 2.创建一个 router 实例const router = new VueRouter({ routes: [ { path: &quot;/&quot;, component: Home }, { path: &quot;/foo&quot;, component: Foo }, { path: &quot;/bar&quot;, component: Bar }, { path: '/é', component: Unicoede } ]});// 3.创建一个Vue实例new Vue({ // 引入前一步创建的vue实例 router, template: ` &lt;div id=&quot;app-content&quot;&gt; &lt;h1&gt;Basic&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to=&quot;/&quot;&gt;/&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/foo&quot;&gt;/foo&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/bar&quot;&gt;/bar&lt;/router-link&gt; &lt;/li&gt; &lt;!-- router-link 可以渲染成其他的组件，这里就渲染成了li，虽然中间包裹的 &lt;a&gt; 标签指向 /bar， 但实际运行时 依然是连接到foo--&gt; &lt;router-link tag=&quot;li&quot; to=&quot;/foo&quot; :event=&quot;['mousedown','touchstart']&quot;&gt; &lt;a&gt;/bar&lt;/a&gt; &lt;/router-link&gt; &lt;/ul&gt; &lt;router-view class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; `}).$mount('#app');","link":"/2018/11/29/vue-vuerouter-basic/"},{"title":"取余和取模的区别","text":"取余% 和 取模 mod 两种运算，既有相同之处也有不同的地方 a % b 和 a mod b 的公式都为 result = a - b * c ;c = a / b (b ≠ 0); 两者的区别是 在于 c 的计算方式 在 a % b 时 ,c的结果向零取整，如 a = 36, b = -10 则 c=-3; 在 a mod b 时，c的结果向负无穷取整，如 a = 36, b = -10 则 c=-4因为比 -3.6 小的最接近的一个整数是 -4 ; 所以 有如下的运算 36 % -10 = 36 - (-10) * c = 36 - (-10) *(-3) = 36 -30 = 6，结果为 6 36 mod 10 = 36 - (-10) * c = 36 - (-10) * (-4) = 36 -40 = -4 ,结果为 -4 更一般的规律 在 取余(%)运算中，运算结果的符号和被除数(a)保持一致，即 a 为正，运算的结果就为正， a 为负，运算的结果就为负 在 取模(mod)运算中，运算结果的符号和除数(b)保持一致，即 b 为正，运算的结果就为正， b 为负，运算的结果就为负 在 java 中的运行结果 123456789101112131415161718192021public static void main(String[] args) { System.out.println(36 % 10); //6 System.out.println(36 % -10); //6 System.out.println(-36 % 10); //-6 System.out.println(-36 % -10); //-6 System.out.println(Math.floorMod(36, 10)); //6 System.out.println(Math.floorMod(36, -10)); //-4 System.out.println(Math.floorMod(-36, 10)); //4 System.out.println(Math.floorMod(-36, -10)); //-6 }打印结果如下66-6-66-44-6","link":"/2020/06/04/%E5%8F%96%E4%BD%99%E5%92%8C%E5%8F%96%E6%A8%A1%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"尚硅谷k8s笔记","text":"","link":"/2020/07/09/%E5%B0%9A%E7%A1%85%E8%B0%B7k8s%E7%AC%94%E8%AE%B0/"},{"title":"新建一个Vue项目","text":"以下操作步骤基于 Vue CLI 3.0 （@vue/cli） 0、安装Vue脚手架使用下面的命令全局安装 Vue CLI 1npm install -g @vue/cli 安装完成之后，可以使用下面的命令来检查是否安装正确 1vue -version 1. 新建一个项目使用下面的命令新建一个名为 vue-playlist 的项目 1vue create vue-playlist 创建成功之后会提示安装的组件，这里可以选择默认 也可以手动选择组件 安装成功之后，使用下面的命令进入目录 1cd vue-playlist 然后运行下面的命令启动程序 1npm run serve 启动成功后，在 http://localhost:8080 即可看到","link":"/2018/12/11/%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAVue%E9%A1%B9%E7%9B%AE/"},{"title":"查看git日志的命令","text":"查看日志 1git log 查看近两次提交的日志 1git log -2 查看近两周提交的日志 1git log --since=2.weeks 查看某一天提交的日志 1git log --since=2019--01--14 查看最近两年三个月前天3分钟的日志 1git log --since=&quot;2 years 1 day 3 minutes ago&quot; log查看分支图 1git log --oneline --all --graph 显示提交的差异 1git log --patch 查看某一段时间内的提交记录 1git log --since=&quot;2024-1-07&quot; --until=&quot;2024-1-17&quot; --pretty= --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;添加的行数：%s, 删除的行数：%s, 总行数：%s\\n&quot;, add, subs, loc }' - 结果是 1添加的行数：142, 删除的行数：100, 总行数：42","link":"/2019/01/14/%E6%9F%A5%E7%9C%8Bgit%E6%97%A5%E5%BF%97%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"title":"正则表达式相关","text":"提取中括号中间的内容12345678910111213141516String s = &quot;[102.8164002309, 24.9892758419], [102.8165296922, 24.9887447331], [102.8168627242, 24.9887980873], [102.8169049102, 24.9890462091], [102.816831012, 24.989382232], [102.8166749033, 24.9893820851], [102.8164002309, 24.9892758419]&quot;; // 包含中括号 Pattern pattern = Pattern.compile(&quot;(\\\\[.*?])&quot;); // 不包含中括号 Pattern pattern1 = Pattern.compile(&quot;\\\\[(.*?)]&quot;); Matcher matcher = pattern.matcher(s); while (matcher.find()) { System.out.println(matcher.group(1)); } System.out.println(&quot;------------------------&quot;); Matcher matcher2 = pattern1.matcher(s); while (matcher2.find()) { System.out.println(matcher2.group(1)); } } 打印结果如下： 123456789101112131415[102.8164002309, 24.9892758419][102.8165296922, 24.9887447331][102.8168627242, 24.9887980873][102.8169049102, 24.9890462091][102.816831012, 24.989382232][102.8166749033, 24.9893820851][102.8164002309, 24.9892758419]------------------------102.8164002309, 24.9892758419102.8165296922, 24.9887447331102.8168627242, 24.9887980873102.8169049102, 24.9890462091102.816831012, 24.989382232102.8166749033, 24.9893820851102.8164002309, 24.9892758419","link":"/2020/10/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3/"},{"title":"线程安全","text":"ThreadSafe and NotThreadSafe Thread safety can be unexpectedly subtle because, in the absence of sufﬁcientsynchronization, the ordering of operations in multiple threads is unpredictableand sometimes surprising. 线程安全因为没有足够的同步机制可能会产生不可预测甚至出人意料的效果，下面的代码在多线程中可能产生异常。代码的本意是产生一个整型数字序列，但是多线程的情况下可能出现数字重复的情况12345678910@NotThreadSafepublic class UnsafeSequence { private int value; public int getNext() { return value++; } }figure 1.1展示了多线程情况下可能出现的问题 The problem with UnsafeSequence is that with some unlucky timing, two threads could call getNext and receive the same value. Figure 1.1 shows how this can happen. The increment notation, someVariable++,may appear to be a single operation, but is in fact three separate operations: read the value, add one to it, and write out the new value. Since operations in multiple threads may be arbitrarily interleaved by the runtime, it is possible for two threads to read the value at the same time, both see the same value, and then both add one to it. The result is that the same sequence number is returned from multiple calls in different threads. 自增1的操作，看以来像是一个操作，其实分为三部分： 读数值 将读出的数值加1 写数值 如果两个线程在同一时间读出了相同的数值，则加1之后会出现两个相同的数字","link":"/2018/11/01/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"title":"设计模式设计原则","text":"单一职责原则(Single Responsibility Principle,SRP) 一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 开闭原则（Open-Closed Principle,OCP） 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 里氏替换原则（Liskov Substitution Principle,LSP） 所有引用基类（父类）的地方必须透明地使用其子类对象。 里氏替换原则表名，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来不成立，如果一个软件实体使用的是一个子类对象的话，那么它一定能够使用基类对象。 依赖倒置原则（Dependency Inversion Princople,DIP） 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口变成，而不是针对实现编程。 以来倒置原则要求在程序代码中传递参数时或在关联关系中，尽量引用高层次的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型转换等，而不要用具体类来做这些事情。 开闭原则是目标，里氏代换是基础，依赖倒置原则是手段，它们相辅相成。 接口隔离原则(Interface Segregation Principle,ISP) 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 合成复用原则（Composition/Aggregate Reuse Principle,CARP） 尽量使用对象组合，而不是继承来达到复用的目的 迪米特法则（Law of Demeter,LoD） 一个软件实体应当尽可能少地与其他实体发生相互作用。","link":"/2021/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"title":"Java泛型","text":"泛型是从 Java 5 开始增加的对于数据类型的规范和检测机制，使用泛型有如下两个优点 可以有效地避免 ClassCastException ，在编译期就可以使用泛型发现类型转换错误，或者类型不匹配 避免强类型转换 一、泛型引入请看下面的例子 1234567891011121314151617public class ShowExample { public static void main(String[] args) { List list = new ArrayList(); // 往 list 中添加一个 String list.add(&quot;这是一个String&quot;); // 往 list 中添加一个 整形 list.add(123); printSomeThing(list); } public static void printSomeThing(List list) { for (int i = 0; i &lt; list.size(); i++) { // 进行类型转换 String temp = (String) list.get(i); System.out.println(temp); } }} 运行结果如下 12这是一个StringException in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String 第一行被正确打印，但是第二行的整形却在进行强制类型转换的时候失败了，这个如果发生在程序运行期间，会给整个项目带来安全问题。所以，如果能在编译期间就发现这个问题，会对程序的健壮性有很大的提高。 泛型使用一对尖括号来设置变量的类型，多用在集合框架中。比如，如下代码定义了一个只能存放 String 类型数据的 List 。 1List&lt;String&gt; stringList = new ArrayList&lt;String&gt;(); 二、泛型类当类中要操作的引用数据类型不确定时，就需要使用泛型。 JDK 1.5 之前使用 Object 来完成扩展现在我们需要定义一个工具类用来设置和获取属性值，在没有泛型之前，可以通过下面的方法实现 123456789101112131415161718192021222324252627282930public class GenericClassDemo { public static void main(String[] args) { ToolOld toolOld = new ToolOld(); // 通过 Object 暂存数据 toolOld.setObject(new Cat()); // 将数据强制装换回原来的类型 Cat cat = (Cat) toolOld.getObject(); // 如果强制准换的类型于原来的类型不一致，就会出现类型转换错误 // ClassCastException // Dog dog = (Dog) toolOld.getObject(); }}class Cat {}class Dog {}/** * 此方法可以用来暂存和获取一个对象 */class ToolOld { private Object object; public Object getObject() { return object; } public void setObject(Object object) { this.object = object; }} 运行结果没有报错，因为 Object 是所有类的父类，上面的 ToolOld 通过 object 属性暂存数据，当需要获取数据时再通过强制转换，转换成原来的类型。 定义泛型类泛型类的定义方法如下 1234567public class ClassName&lt;泛型标识符&gt; { private 泛型标识符 属性名称; // 定义一个参数类型是指定泛型的方法 private void testMethod(T t) { ... }} 使用泛型类上面 Object 的方法可以使用泛型来代替。下面定义了一个泛型类 ToolGeneric，每次创建对象时可以传入类型，在调用 set 方法时，如果类型不匹配，则编译不会通过。 1234567891011121314151617181920212223242526272829public class GenericClassDemo { public static void main(String[] args) { // 这里指定了类中只能传入 toolGeneric 类型 ToolGeneric&lt;Cat&gt; toolGeneric = new ToolGeneric&lt;Cat&gt;(); // 如果传入 new Dog() 就会报错 toolGeneric.setT(new Cat()); Cat cat = toolGeneric.getT(); }}class Cat {}class Dog {}// 泛型类 传入的类型用T来标记class ToolGeneric&lt;T&gt; { private T t; public T getT() { return t; } // 调用set 函数时传入的参数类型必须与创建对象时泛型的类型相同 public void setT(T t) { this.t = t; }} 另一个泛型类的例子 123456789101112131415161718192021222324252627public class GenericClassShowCase { public static void main(String[] args) { PrintTool&lt;String&gt; printToolStr = new PrintTool&lt;String&gt;(); printToolStr.printSomeThing(&quot;你好&quot;); // 因为已经指定 printToolStr 传入的类型为 String 下面的语句不能通过编译 // printToolStr.printSomeThing(12312); PrintTool&lt;Integer&gt; printToolInt = new PrintTool&lt;Integer&gt;(); printToolInt.printSomeThing(3123412); // 因为已经指定 printToolStr 传入的类型为 Integer 下面的语句不能通过编译 // printToolInt.printSomeThing(&quot;你好&quot;); }}class PrintTool&lt;T&gt; { public void printSomeThing(T t) { System.out.println(t); } // 需要注意的是 静态方法不能引用上面的泛型 T， // 但是可以定义泛型静态方法 // 'PrintTool.this' cannot be referenced from a static context /* public static void showIt(T t) { System.out.println(t); }*/} 运行结果 ： 12你好3123412 上面的泛型类通过每次指定不同的类型，可以打印不同的数据类型。但是每打印一个新的数据类型都需要运行 PrintTool&lt;XXX&gt; printTool = new PrintTool&lt;XXX&gt;() 来创建新的类，这样也不方便，所以有必要使用泛型方法。 泛型方法泛型方法定义时需要将一对尖括号包裹的泛型类型写在函数的返回值之前。 123public &lt;T&gt; void getName(T t) { // TODO} 下面是一个泛型方法的例子 12345678910111213141516171819202122232425262728293031323334353637public class GenericMethodShow { public static void main(String[] args) { GenericMethod&lt;String&gt; stringGenericMethod = new GenericMethod&lt;String&gt;(); stringGenericMethod.show(&quot;你好&quot;); // 编译不通过，应为 show 方法使用的是类传来的参数类型， // 所以在本例中只能打印 String 类型的数据 // stringGenericMethod.show(13123); // show 方法的参数类型在调用时通过传入的参数确定， // 所以两种类型都可以打印 stringGenericMethod.print(&quot;你好&quot;); stringGenericMethod.print(123124); // 调用静态泛型方法 GenericMethod.showStatic(&quot;static&quot;); }}class GenericMethod&lt;T&gt; { // 这是一个普通的方法，只是参数的类型是泛型 public void show(T t) { System.out.println(&quot;show: &quot; + t); } // 这是一个泛型方法,这里泛型使用的是 T2，而不是类中的T public &lt;T2&gt; void print(T2 t) { System.out.println(&quot;print: &quot; + t); } // 静态方法可以定义泛型函数，可以使用用户调用时传入的参数的类型 T3 // 但是无法使用本类的泛型 T public static &lt;T3&gt; void showStatic(T3 t3) { System.out.println(&quot;static: &quot; + t3); }} 1234show: 你好print: 你好print: 123124static: static 泛型接口泛型接口的定义方式为 IterName{12interface IterName&lt;T&gt;{} 泛型接口使用时可以在泛型类的定义时传入泛型的类型，也可以在调用方法时通过参数来确定泛型的类型 12345678910111213141516171819202122232425262728293031323334353637public class GenericInterfaceShow { public static void main(String[] args) { ShowInterImpl1 showInterImpl1 = new ShowInterImpl1(); showInterImpl1.show(&quot;哈哈&quot;); // 编译不通过 //showInterImpl1.show(123); ShowInterImpl2 showInterImpl2 = new ShowInterImpl2(); // 在调用时确定参数类型 showInterImpl2.show(&quot;哈哈2&quot;); showInterImpl2.show(1234); }}// 定义一个泛型接口interface ShowInter&lt;T&gt; { void show(T t);}// 在定义接口类时传入泛型class ShowInterImpl1 implements ShowInter&lt;String&gt; { @Override // 这里的参数类型必须写 String public void show(String s) { System.out.println(s); }}// 在调用时定义参数类型// 方法定义时必须在类名和接口名后都加入泛型class ShowInterImpl2&lt;T&gt; implements ShowInter&lt;T&gt; { @Override public void show(T t) { System.out.println(t); }} 运行结果如下 123哈哈哈哈21234 泛型限定当不知道数据类型时，可以用 ? 作为通配符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class GenericExtends { public static void main(String[] args) { ArrayList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;(); personList.add(new Person(&quot;aaa&quot;)); personList.add(new Person(&quot;bbb&quot;)); personList.add(new Person(&quot;ccc&quot;)); ArrayList&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;(); personList.add(new Person(&quot;aaa1&quot;)); personList.add(new Person(&quot;bbb2&quot;)); personList.add(new Person(&quot;ccc3&quot;)); // printData(personList); // printData(studentList); ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;(); strings.add(&quot;a&quot;); strings.add(&quot;b&quot;); strings.add(&quot;c&quot;); ArrayList&lt;Integer&gt; integers = new ArrayList&lt;Integer&gt;(); integers.add(1); integers.add(2); integers.add(3); printData(strings); printData(integers); } // 使用 ? 作为限定符 public static void printData(ArrayList&lt;?&gt; dataList) { Iterator&lt;?&gt; iterator = dataList.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } // 这里也可以使用T, 这种写法与 printData 的差别不大，区别在于可以通过 t 对变量进行操作 public static &lt;T&gt; void printData2(ArrayList&lt;T&gt; dataList) { Iterator&lt;T&gt; iterator = dataList.iterator(); while (iterator.hasNext()) { T t = iterator.next(); System.out.println(t); } }} 运行结果如下 123456abc123 可以看出：使用 ? 可以匹配不同类型的数据 这个例子说明 子父类之间的泛型不能通过多态调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 泛型限定public class GenericExtends { public static void main(String[] args) { ArrayList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;(); personList.add(new Person(&quot;aaa&quot;)); personList.add(new Person(&quot;bbb&quot;)); personList.add(new Person(&quot;ccc&quot;)); ArrayList&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;(); studentList.add(new Student(&quot;aaa1&quot;)); studentList.add(new Student(&quot;bbb2&quot;)); studentList.add(new Student(&quot;ccc3&quot;)); printPerson(personList); // 下面的代码编译不通过 // 说明 ArrayList&lt;Person&gt; peopleList = new ArrayList&lt;Student&gt;();是不成立的 // 同样 ArrayList&lt;Student&gt; peopleList = new ArrayList&lt;Person&gt;(); 也是不成立的 // printPerson(studentList); } public static void printPerson(ArrayList&lt;Person&gt; personList) { Iterator&lt;Person&gt; iterator = personList.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next().getName()); } }}class Person { private String name; public Person(String name) { this.name = name; } public String getName() { return name; }}class Student extends Person { public Student(String name) { super(name); }} 现在我们确实需要使用 printPerson 方法来打印 studentList ，将 printPerson 申明为泛型方法是一个途径： 12345678public static &lt;T&gt; void printPerson(ArrayList&lt;T&gt; personList) { Iterator&lt;T&gt; iterator = personList.iterator(); while (iterator.hasNext()) { System.out.println(((Person) iterator.next()).getName()); } } 或者使用 ？ 1234567public static void printPerson(ArrayList&lt;?&gt; personList) { Iterator&lt;?&gt; iterator = personList.iterator(); while (iterator.hasNext()) { System.out.println(((Person) iterator.next()).getName()); }} 但是这两种方法都有局限性：无论 personList 中存储的是什么类型的数据都可以传入。这就存在了风险：就上面的例子来说，如果 personList 里边存储的不是 Person 类（或者子类），就会造成类型转换异常。为了解决这个问题，引入了类型限定。 使用 &lt;? extends Person&gt; 来限定 personList 只能存储 Person 类或者其子类型。 下面是一个类型限定的例子 123456public static void printPersonExtend(ArrayList&lt;? extends Person&gt; personList) { Iterator&lt;? extends Person&gt; iterator = personList.iterator(); while(iterator.hasNext()) { System.out.println(iterator.next().getName()); }} 增加一个汽车类 Car 123456789101112131415class Car { private String brandName; public Car(String brandName) { this.brandName = brandName; } public String getBrandName() { return brandName; } public void setBrandName(String brandName) { this.brandName = brandName; }} 调用打印方法 123456789101112131415161718192021222324252627282930313233public class GenericExtends { public static void main(String[] args) { ArrayList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;(); personList.add(new Person(&quot;aaa&quot;)); personList.add(new Person(&quot;bbb&quot;)); personList.add(new Person(&quot;ccc&quot;)); ArrayList&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;(); studentList.add(new Student(&quot;aaa1&quot;)); studentList.add(new Student(&quot;bbb2&quot;)); studentList.add(new Student(&quot;ccc3&quot;)); // 打印 Person printPersonExtend(personList); // 因为 Stduent 是 Person 的子类，所以也可以打印 printPersonExtend(studentList); ArrayList&lt;Car&gt; carList = new ArrayList&lt;Car&gt;(); carList.add(new Car(&quot;Benz&quot;)); carList.add(new Car(&quot;BMW&quot;)); carList.add(new Car(&quot;Porsche&quot;)); // 编译失败，因为 Car 类和 Person 类没有任何关系 // printPersonExtend(carList); } public static void printPersonExtend(ArrayList&lt;? extends Person&gt; personList) { Iterator&lt;? extends Person&gt; iterator = personList.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next().getName()); } } 与此同时，使用 &lt;? super Student&gt; 限定只能传入 Student 类及其父类，TreeSet 的一个构造方法就使用如下的限定符： 123public TreeSet(Comparator&lt;? super E&gt; comparator) { this(new TreeMap&lt;E,Object&gt;(comparator));} 下面是一个使用 &lt;? super E&gt; 的例子: 定义一个 Worker 类，它同时也是 Person 的子类 123456class Worker extends Person { public Worker(String name) { super(name); }} 现在我们用 TreeSet 分别存储 学生 和 工人，并将它们倒序输出 12345678910111213141516171819202122232425262728293031323334353637383940414243public class GenericSuper { public static void main(String[] args) { // 创建 studentTreeSet 并用 StudentComparator 指定比较的方法 TreeSet&lt;Student&gt; studentTreeSet = new TreeSet&lt;Student&gt;(new StudentComparator()); studentTreeSet.add(new Student(&quot;s--001&quot;)); studentTreeSet.add(new Student(&quot;s--002&quot;)); studentTreeSet.add(new Student(&quot;s--003&quot;)); Iterator&lt;Student&gt; studentIterator = studentTreeSet.iterator(); while (studentIterator.hasNext()) { System.out.println(studentIterator.next().getName()); } // 创建 studentTreeSet 并用 WorkerComparator 指定比较的方法 TreeSet&lt;Worker&gt; workerTreeSet = new TreeSet&lt;Worker&gt;(new WorkerComparator()); workerTreeSet.add(new Worker(&quot;w--001&quot;)); workerTreeSet.add(new Worker(&quot;w--002&quot;)); workerTreeSet.add(new Worker(&quot;w--003&quot;)); Iterator&lt;Worker&gt; workerIterator = workerTreeSet.iterator(); while (workerIterator.hasNext()) { System.out.println(workerIterator.next().getName()); } }}// 用来比较 Student 对象class StudentComparator implements Comparator&lt;Student&gt; { @Override public int compare(Student s1, Student s2) { return s2.getName().compareTo(s1.getName()); }}// 用来比较 Worker 对象class WorkerComparator implements Comparator&lt;Worker&gt; { @Override public int compare(Worker w1, Worker w2) { return w2.getName().compareTo(w1.getName()); }} 输出结果如下 123456s--003s--002s--001w--003w--002w--001 上面两种不同的对象比较，使用了不同的比较器，是否可以将其合并成一个呢？ 查看源码 TreeSet 当前的构造函数如下 123public TreeSet(Comparator&lt;? super E&gt; comparator) { this(new TreeMap&lt;E,Object&gt;(comparator));} 这个源码说明比较器参数可以传入 E 类型，或者 E 类型的 父类型 现在重写一个通用的比较器 12345678// 这里指定了类型时 Student 和 Worker 的共同父类 Person // 所以，当传入 Student 或者 Worker 时，比较器都是可以使用的 class AllPersonComp implements Comparator&lt;Person&gt; { @Override public int compare(Person s1, Person s2) { return s2.getName().compareTo(s1.getName()) }} 在定义 TreeSet 时传入上面的比较器 12345678910111213141516171819202122232425262728public class GenericSuper { public static void main(String[] args) { // 构造函数中传入的泛型是Student，后面的参数就可以传入以Student的父类作为泛型的比较器 TreeSet&lt;Student&gt; studentTreeSet = new TreeSet&lt;Student&gt;(new AllPersonComp()); studentTreeSet.add(new Student(&quot;s--001&quot;)); studentTreeSet.add(new Student(&quot;s--002&quot;)); studentTreeSet.add(new Student(&quot;s--003&quot;)); Iterator&lt;Student&gt; studentIterator = studentTreeSet.iterator(); while (studentIterator.hasNext()) { System.out.println(studentIterator.next().getName()); } // 构造函数中传入的泛型是Worker，后面的参数就可以传入以Worker的父类作为泛型的比较器 TreeSet&lt;Worker&gt; workerTreeSet = new TreeSet&lt;Worker&gt;(new AllPersonComp()); workerTreeSet.add(new Worker(&quot;w--001&quot;)); workerTreeSet.add(new Worker(&quot;w--002&quot;)); workerTreeSet.add(new Worker(&quot;w--003&quot;)); Iterator&lt;Worker&gt; workerIterator = workerTreeSet.iterator(); while (workerIterator.hasNext()) { System.out.println(workerIterator.next().getName()); } }} 运行结果与上面相同","link":"/2019/03/14/Java%E6%B3%9B%E5%9E%8B/"},{"title":"rabbitmq基础","text":"Simple Queues 简单队列 生产者 12345678910111213141516171819202122232425262728293031323334package com.mmr.myrabbitmq.util.simple;import com.mmr.myrabbitmq.util.ConnectionUtils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * 一个生产者对应多个一个消费者 */public class Send { public static final String QUEUE_NAME = &quot;test_simple_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException { // 获取一个连接 Connection connection = ConnectionUtils.getConnection(); // 从中获取一个通道 Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); String msg = &quot;Hello Simple&quot;; // 发送消息 channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes()); // 关闭资源 channel.close(); connection.close(); }} 消费者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.mmr.myrabbitmq.util.simple;import com.mmr.myrabbitmq.util.ConnectionUtils;import com.rabbitmq.client.*;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.concurrent.TimeoutException;/** * @author Bruce Liu * @version V1.0.0 * @ClassName Recv * @Description * @date 2019-11-30 16:44 */public class Recv { public static final String QUEUE_NAME = &quot;test_simple_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); DefaultConsumer defaultConsumer = new DefaultConsumer(channel) { // 重写此方法 收到消息之后如何进行处理 @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws UnsupportedEncodingException { String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;收到了消息&quot; + msg); } }; // 进行监听 channel.basicConsume(QUEUE_NAME, true, defaultConsumer); /** * 早期的写法 * QueueingConsume consume = new QueueingConsume(channel); * channel.basicConsume(QUEUE_NAME,true,consume); * while (true) { * Delivery delivery = consumer.nextDelivery(); * String msg = new String(delivery.getBody()); * * } */ }} 总结 简单队列的不足 ：耦合性高，生产者——对应消费者（如果想有多个消费者 消费 队列中的消息，不能实现） 队列名变更，消费者需要同时变更 Work Queues 工作队列 为什么会出现工作队列 Simple 队列 是一一对应的，而实际生产环境中，生产者发消息是后不费力的，而消费者一般要跟业务相关联，处理是比较耗费时间的 轮询模式 生产者 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.mmr.myrabbitmq.util.work;import com.mmr.myrabbitmq.util.ConnectionUtils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * @author Bruce Liu * @version V1.0.0 * @ClassName Send * @Description * @date 2019-11-30 17:19 */public class Send { public static final String QUEUE_NAME = &quot;test_work_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { // 获取连接 Connection connection = ConnectionUtils.getConnection(); // 获取Channel Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); for (int i = 0; i &lt; 50; i++) { System.out.println(&quot;send&quot; + i + &quot;start&quot;); String msg = &quot;message&quot; + i; channel.basicPublish(&quot;&quot;, &quot;test_work_queue&quot;, false, null, msg.getBytes()); Thread.sleep(i * 20); System.out.println(&quot;send&quot; + i + &quot;done&quot;); } channel.close(); connection.close(); }} 消费者 总共有两个 消费者 Recv1 和 Recv2 将下列代码的 Recv1 改为 Recv2，将休眠时间改为 1000，可得到 Recv2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.mmr.myrabbitmq.util.work;import com.mmr.myrabbitmq.util.ConnectionUtils;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * @author Bruce Liu * @version V1.0.0 * @ClassName Send * @Description * @date 2019-11-30 17:19 */public class Recv1 { public static final String QUEUE_NAME = &quot;test_work_queue&quot;; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { // 获取连接 Connection connection = ConnectionUtils.getConnection(); // 获取Channel Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); DefaultConsumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;RECV1----&gt;&quot; + msg); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(&quot;RECV1 DONE!&quot;); } } }; boolean autoAck = true; channel.basicConsume(QUEUE_NAME, true, consumer); }} 现象先启动 生产者 再启动消费者 发现 两个消费者 一个接收到的消息 全是偶数，另一个全是奇数1 这种方式叫做轮询分发（round-robin）结果就是不管谁忙，谁清闲，都不会多给一个消息，任务消息总是你一个，我一个。 公平模式 生产者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.mmr.myrabbitmq.util.workfair;import com.mmr.myrabbitmq.util.ConnectionUtils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * @author Bruce Liu * @version V1.0.0 * @ClassName Send * @Description * @date 2019-11-30 17:19 */public class Send { public static final String QUEUE_NAME = &quot;test_work_queue_work_fair&quot;; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { // 获取连接 Connection connection = ConnectionUtils.getConnection(); // 获取Channel Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); /** * 每个消费者发送确认消息之前，消息队列不发送下一个消息到消费者，一次只能处理一个 * 限制发送给同一消费者，不得超过一条数据 */ // channel.basicQos(1); for (int i = 0; i &lt; 50; i++) { System.out.println(&quot;send&quot; + i + &quot;start&quot;); String msg = &quot;message&quot; + i; channel.basicPublish(&quot;&quot;, QUEUE_NAME, false, null, msg.getBytes()); Thread.sleep(i * 20); System.out.println(&quot;send&quot; + i + &quot;done&quot;); } channel.close(); connection.close(); }} 消费者 总共有两个 消费者 Recv1 和 Recv2 将下列代码的 Recv1 改为 Recv2，将休眠时间改为 1000，可得到 Recv2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.mmr.myrabbitmq.util.workfair;import com.mmr.myrabbitmq.util.ConnectionUtils;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * @author Bruce Liu * @version V1.0.0 * @ClassName Send * @Description * @date 2019-11-30 17:19 */public class Recv1 { public static final String QUEUE_NAME = &quot;test_work_queue_work_fair&quot;; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { // 获取连接 Connection connection = ConnectionUtils.getConnection(); // 获取Channel Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 保证一次只有一个消息 channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;RECV1----&gt;&quot; + msg); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(&quot;RECV1 DONE!&quot;); channel.basicAck(envelope.getDeliveryTag(),false); } } }; boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); }} 现象 消费者2处理的消息比消费者1多，能者多劳； Public/Subscribe 发布订阅模式 解读 一个生产者，多个消费者 每一个消费者都有自己的队列 生产者没有直接把消息发送到队列，而是发送到了交换机 exchange 每个队列都要绑定到交换机上 生产者发送的消息，经过交换机到达队列，就能实现一个消息被多个消费者消费 生产者 123456789101112131415161718public class Send { private static final String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] args) throws IOException, TimeoutException { final Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); //声明交换机 // 这里的type 必须指定为 ExchangeTypes.FANOUT(fanout) channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.FANOUT); // 发送消息 String msg = &quot;hello ps&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, false, null, msg.getBytes()); System.out.println(&quot;发送了&quot; + msg); channel.close(); connection.close(); }} 消费者1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.mmr.myrabbitmq.ps;import com.mmr.myrabbitmq.util.ConnectionUtils;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * @author Bruce Liu * @version V1.0.0 * @ClassName Recv1 * @Description * @date 2019-11-30 21:18 */public class Recv1 { private static final String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static final String QUEUE_NAME = &quot;test_queue_fanout_email&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); DefaultConsumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;RECV1----&gt;&quot; + msg); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(&quot;RECV1 DONE!&quot;); channel.basicAck(envelope.getDeliveryTag(),false); } } }; boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); }} 消费者2 12345678910111213141516171819202122232425262728293031public class Recv2 { private static final String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static final String QUEUE_NAME = &quot;test_queue_fanout_sms&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); DefaultConsumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;RECV2----&gt;&quot; + msg); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(&quot;RECV2 DONE!&quot;); channel.basicAck(envelope.getDeliveryTag(), false); } } }; boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); }} 现象 邮件队列 和 短信队列 都能收到同一条消息 Routing 路由模式 配置了相同 routingKey 的消费者才能收到消息 生产者 1234567891011121314151617public class Send { private static final String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); // 这里的 type 必须指定为 ExchangeTypes.DIRECT(direct) channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.DIRECT); String msg = &quot;hello direct!&quot;; // 在这里指定 routingKey String routingKey = &quot;info&quot;; System.out.println(&quot;发送了&quot; + msg); channel.basicPublish(EXCHANGE_NAME, routingKey, false, null, msg.getBytes()); channel.close(); connection.close(); }} 消费者1 1234567891011121314151617181920212223242526272829303132public class Recv1 { private static final String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; public static final String QUEUE_NAME = &quot;test_queue_direct_1&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); channel.basicQos(1); // 这里指定 接收 routingKey 为 &quot;error&quot; 的消息 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;error&quot;); DefaultConsumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;RECV1----&gt;&quot; + msg); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(&quot;RECV1 DONE!&quot;); channel.basicAck(envelope.getDeliveryTag(), false); } } }; boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); }} 消费者2 12345678910111213141516171819202122232425262728293031323334public class Recv2 { private static final String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; public static final String QUEUE_NAME = &quot;test_queue_direct_2&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); channel.basicQos(1); // 这里指定 接收 routingKey 为 &quot;error&quot; 或者 &quot;info&quot; 的消息 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;error&quot;); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;info&quot;); channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;RECV2 ----&gt;&quot; + msg); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(&quot;RECV2 DONE!&quot;); channel.basicAck(envelope.getDeliveryTag(), false); } } }; boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); }} 现象 当生产者 发送消息时 routingKey = error 时，两个 消费者都能收到 当生产者 发送消息时 routingKey = info 时，只有消费者 2 能收到消息 主题模式 topic 使用匹配符 * 匹配一项，# 匹配多项 生产者 123456789101112131415161718public class Send { private static final String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; //public static final String QUEUE_NAME = &quot;test_queue_fanout_email&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.TOPIC); String msg = &quot;商品。。。&quot;; // 匹配商品的新增业务 channel.basicPublish(EXCHANGE_NAME, &quot;goods.add&quot;, null, msg.getBytes()); System.out.println(&quot;---send&quot; + msg); channel.close(); connection.close(); }} 消费者1 123456789101112131415161718192021222324252627282930public class Recv1 { private static final String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static final String QUEUE_NAME = &quot;test_queue_topic_1&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); channel.basicQos(1); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;goods.#&quot;); DefaultConsumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;RECV1 ----&gt;&quot; + msg); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(&quot;RECV1 DONE!&quot;); channel.basicAck(envelope.getDeliveryTag(), false); } } }; boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); }} 消费者2 123456789101112131415161718192021222324252627282930313233public class Recv2 { private static final String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static final String QUEUE_NAME = &quot;test_queue_topic_2&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); channel.basicQos(1); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;goods.add&quot;); DefaultConsumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;RECV2 ----&gt;&quot; + msg); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(&quot;RECV2 DONE!&quot;); channel.basicAck(envelope.getDeliveryTag(), false); } } }; boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); }} 现象 当生产者 发送消息时 routingKey = goods.add 时，两个 消费者都能收到 当生产者 发送消息时 routingKey = goods.insert 时，只有消费者 1 能收到消息, 因为good.# 匹配所有goods开始的 routingKey。 rabbitmq 的消息确认机制（事务+confirm）在 rabbitmq 中，我们可以持久化数据，解决 rabbitmq 服务器异常的数据丢失问题。 问题：生产者将消息发送出去之后，消息有没有到达 rabbitmq ,服务器默认的情况是不知道可。 两种方式 AMQP 实现了事务机制 Confirm 模式 事务机制txSelect txCommit txRollback; txSelect : 用于将当前 channel 设置 transaction 模式 txCommit: 用于提交事务。 txRollback: 回滚事务 生产者 1234567891011121314151617181920212223242526272829303132333435363738394041package com.mmr.myrabbitmq.tx;import com.mmr.myrabbitmq.util.ConnectionUtils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * @author Bruce Liu * @version V1.0.0 * @ClassName Send * @Description * @date 2019-12-01 14:13 */public class TxSend { public static final String QUEUE_NAME = &quot;test_queue_tx&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); String msg = &quot;hello tx&quot;; try { channel.txSelect(); channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes()); // 当出错时 不会进行提交 // int xx = 1 / 0; channel.txCommit(); } catch (Exception e) { channel.txRollback(); System.out.println(&quot;sendMsgRollBack&quot;); } finally { channel.close(); connection.close(); } }} 消费者 123456789101112131415161718public class Recv { public static final String QUEUE_NAME = &quot;test_queue_confirm1&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(&quot;recv tx&quot; + new String(body, &quot;utf-8&quot;)); } }); }} Confirm 模式生产者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Send3 { public static final String QUEUE_NAME = &quot;test_queue_confirm3&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); channel.confirmSelect(); final SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(new TreeSet&lt;Long&gt;()); // 添加一个监听 channel.addConfirmListener(new ConfirmListener() { // 正常收到 确认消息 @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException { if (multiple) { System.out.println(&quot;-----handleAck-------multiple&quot;); confirmSet.headSet(deliveryTag + 1).clear(); } else { System.out.println(&quot;-----handleAck-------multiple false&quot;); confirmSet.remove(deliveryTag); } } @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException { if (multiple) { System.out.println(&quot;-----handleNAck-------multiple&quot;); confirmSet.headSet(deliveryTag + 1).clear(); } else { System.out.println(&quot;-----handleNAck-------multiple false&quot;); confirmSet.remove(deliveryTag); } } }); String msg = &quot;ssssssss&quot;; while (true) { long seqNo = channel.getNextPublishSeqNo(); channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes()); confirmSet.add(seqNo); } }} 消费者 1234567891011121314public class Recv3 { public static final String QUEUE_NAME = &quot;test_queue_confirm3&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(&quot;recv confirm&quot; + new String(body, &quot;utf-8&quot;)); } }); }} Return 消息机制return listener 用户处理一些不可路由的消息 某些情况下，会出现不可达的消息，这时候就需要使用 Return Listener mandatory 如果为 true，则监听器会收到路由不可达的消息，然后进行后续的处理，如果为 false,则服务器会自动删除该消息。 消费端限流防止消费端收到大量的消息，而使服务端挂掉 RabbitMQ 提供了一种 qos（服务质量保证） 功能，即在非自动确认消息的前提下，如果一定数目的消息（通过基于consume 或者 channel 设置qos 的值）未被确认前，不进行消费新的消息。 在consumer 端有如下的函数来设置参数 void basicQos 1channel.basicNack(envelope.getDeliveryTag(), false, true); TTL time to live 在消息上加过期时间 在队列上加超时时间 DLX 死信队列（交换机）消息变为私信有以下几种情况 消息被拒绝（basic.reject/basic.nack）并且 requeue=false 消息 TTL 过期 当队列长度达到队列长度 DLX 也是一个正常的Exchange，和一般的Exchange没有区别，他能在任何的队列上被指定，实际上就是设置某个队列的属性 当这个队列中有死信时，RabbitMq 就会自动地将这个消息重新发布到设置的Exchange中去，进而被路由到另外一个队列死信队列的 exchange 和 queue,，然后进行绑定 声明一个死信队列Exchange: dlx.exchnage Queue: dlx.queue RoutingKey: # 然后正常声明交换机、队列、绑定，只不过需要在队列上加一个参数 1arguments.put(&quot;x-dead-letter-exchange&quot;,&quot;dlx.exchange&quot;) Springboot Spring AMQP实战","link":"/2019/11/30/rabbitmq%E5%9F%BA%E7%A1%80/"},{"title":"Vuex基础","text":"Vuex 是一个专门为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件状态。 也就是将 Vue.js 程序中各个页面公用的数据和获取、改变这些数据的方法抽离出来，方便各个页面调用，以及页面之间的数据传输。 下面通过一个例子来讲解Vuex 我们首先创建一个Vue工程。 我们假设有两个富豪榜，这两个富豪榜分属两个界面，通过组件注册，在一个主界面。 一、使用 props 属性传递参数页面结构如下： 我们在父页面 App.vue 的 data 属性中加入人员列表，并引入两个子页面，通过 v-bind 指令将 data 传递给子页面。 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 将 data 元素传递给子页面 --&gt; &lt;salary-list-one v-bind:sendedSalaryList=&quot;salaryList&quot;&gt;&lt;/salary-list-one&gt; &lt;salary-list-two v-bind:sendedSalaryList=&quot;salaryList&quot;&gt;&lt;/salary-list-two&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import salarylist1 from './components/salarylist1'; import salarylist2 from './components/salarylist2'; export default { name: &quot;app&quot;, data() { return { salaryList: [{ name: &quot;马云&quot;, salaryAmount: 1000 }, { name: &quot;马化腾&quot;, salaryAmount: 900 }, { name: &quot;李彦宏&quot;, salaryAmount: 800 } ] }; }, components: { 'salary-list-one': salarylist1, 'salary-list-two': salarylist2 } };&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 子页面通过 props 属性接收父页面传递过来的参数，并展示出来。 salarylist1.vue 代码如下 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div id=&quot;salary-list-fisrt&quot;&gt; &lt;h2&gt;财富榜&lt;/h2&gt; &lt;ol&gt; // 通过 v-for 命令将其展示出来 &lt;li v-for=&quot;salary in sendedSalaryList&quot;&gt; {{salary.name}}的工资是：{{salary.salaryAmount}} &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: &quot;salary-listfirst&quot;, // 通过 props 属性接收父页面传来的参数 props: { sendedSalaryList: { type: Array, required: true } } }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; salarylist2.vue 代码和上面的代码基本相似 运行结果如下： 二、使用 Vuex 简化数据传递虽然页面之间可以使用 props, $emit 等传递参数，但是这种参数的传递会面临以下问题 问题一 ：多个视图依赖于同一状态。 问题二 ：来自不同视图的行为需要变更同一状态。 对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。 对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？ 在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！ 另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护 如果之前没有安装 vuex，使用下面的命令安装 1npm install vuex --save 在项目根目录下新建 store/store.js 文件，这个文件中保存的就是这个应用中需要共享的内容， 而且整个应用中只有一个。 在 main.js 文件中引入 vuex 1234567891011import Vue from 'vue'import App from './App.vue'import {store} from './store/store'Vue.config.productionTip = falsenew Vue({ store:store, render: h =&gt; h(App),}).$mount('#app') 1. Statestate 类似于 Vue 实例中的 data 属性，不同的是 state 是共享的。 现在将刚才 App.vue 中的 data 保存在store.js 中，将 App.vue 中保存的数据移除。 现在，两个财富榜都没有了数据，如图： 现在改为从 store 请求数据 1234567891011121314151617181920212223// store.jsimport Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);export const store = new Vuex.Store({ state: { storeSalaryList: [{ name: &quot;马云&quot;, salaryAmount: 1000 }, { name: &quot;马化腾&quot;, salaryAmount: 900 }, { name: &quot;李彦宏&quot;, salaryAmount: 800 } ] }}); 在 财富榜2 中引入获取 store 1234567891011121314151617181920212223242526&lt;template&gt; &lt;!--salarylist2.vue --&gt; &lt;div id=&quot;salary-list-fisrt&quot;&gt; &lt;h2&gt;财富榜2&lt;/h2&gt; &lt;ol&gt; &lt;li v-for=&quot;salary in salaryList &quot;&gt; {{salary.name}}的工资是：{{salary.salaryAmount}} &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: &quot;salary-list-first&quot;, computed: { salaryList() { // 通过 computed 属性，获取到 store.js 中的数据，并返回 return this.$store.state.storeSalaryList; } } }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在 App.vue 中去掉 v-bind 指令 123456789101112131415161718192021222324&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;salary-list-one &gt;&lt;/salary-list-one&gt; &lt;salary-list-two &gt;&lt;/salary-list-two&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import salarylist1 from './components/salarylist1';import salarylist2 from './components/salarylist2';export default { name: &quot;app&quot;, data() { return { }; }, components:{ 'salary-list-one':salarylist1, 'salary-list-two':salarylist2 }};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 运行结果如下： 如果在 salarylist1.vue 中也加入上面的 store 引用，就可以连个财富榜就可以全部展示。 2.getter在一些情况下，当获取到 state 的数据之后，我们希望进行一些加工处理再进行展示。 现在，我们将上面每个人的工资翻倍，再增加 美元（$）符号。 修改 salarylist1.vue 和 salarylist2.vue 代码，在 computed 属性中增加，doubleSalary 属性 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div id=&quot;salary-list-fisrt&quot;&gt; &lt;h2&gt;财富榜&lt;/h2&gt; &lt;ol&gt; &lt;li v-for=&quot;salary in doubleSalary&quot;&gt; {{salary.name}}的工资是：{{salary.salaryAmount}} &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { computed: { salaryList() { return this.$store.state.storeSalaryList; }, // doubleSalary 属性对每个人 state 的数据加工后进行返回 doubleSalary() { var afterDoubleSalary = this.$store.state.storeSalaryList.map(salary =&gt; { return { name: salary.name, salaryAmount: salary.salaryAmount * 2 + &quot; &quot; + &quot;$&quot; }; }); return afterDoubleSalary; } }, }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 运行结果如下 以上的代码虽然对 state 属性进行了加工之后返回，但是有一定的局限性，如果有100个页面都要这样处理，是不是就要将 doubleSalary 属性写100遍？这样显然是不合理的，为了解决这个问题，可以 doubleSalary 属性写进 store.js 作为一个 getter 方法。 在 store.js 中增加一个getter 方法 123456789101112131415161718192021222324252627282930313233343536import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);export const store = new Vuex.Store({ state: { storeSalaryList: [{ name: &quot;马云&quot;, salaryAmount: 1000 }, { name: &quot;马化腾&quot;, salaryAmount: 900 }, { name: &quot;李彦宏&quot;, salaryAmount: 800 } ] }, getters: { // 增加一个 getter 方法，用于返回加工后的 工资 doubleSalaryGetter: (state) =&gt; { var afterDoubleSalary = state.storeSalaryList.map(salary =&gt; { return { name: salary.name, salaryAmount: salary.salaryAmount * 2 + &quot; &quot; + &quot;$&quot; }; }); return afterDoubleSalary; } }}); 修改 salarylist1.vue 和 salarylist2.vue 代码，在 computed 属性中增加，doubleSalaryByGetter 属性，在这个属性中，调用 store.js 中的 getter 返回结果。 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id=&quot;salary-list-fisrt&quot;&gt; &lt;h2&gt;财富榜&lt;/h2&gt; &lt;ol&gt; &lt;li v-for=&quot;salary in doubleSalaryByGetter&quot;&gt; {{salary.name}}的工资是：{{salary.salaryAmount}} &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { computed: { salaryList() { return this.$store.state.storeSalaryList; }, // 在这里调用 store.js 中的方法。 doubleSalaryByGetter() { return this.$store.getters.doubleSalaryGetter; } }, }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 如果我们 还有一个需求：计算工资总额，可以在 getter 新增加一个 totalSalary 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);export const store = new Vuex.Store({ state: { storeSalaryList: [{ name: &quot;马云&quot;, salaryAmount: 1000 }, { name: &quot;马化腾&quot;, salaryAmount: 900 }, { name: &quot;李彦宏&quot;, salaryAmount: 800 } ] }, getters: { doubleSalaryGetter: (state) =&gt; { var afterDoubleSalary = state.storeSalaryList.map(salary =&gt; { return { name: salary.name, salaryAmount: salary.salaryAmount * 2 + &quot; &quot; + &quot;$&quot; }; }); return afterDoubleSalary; }, // 在这里增加一个 计算工资总额的方法 totalSalary: (state) =&gt; { var sum = 0 state.storeSalaryList.forEach(element =&gt; { sum += element.salaryAmount; }); return sum*2; } }}); 修改 salarylist1.vue 代码，在 computed 属性中增加，totalSalaryByGetter 属性，在这个属性中，调用 store.js 中的 getter 返回结果。 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;salary-list-fisrt&quot;&gt; &lt;h2&gt;财富榜&lt;/h2&gt; &lt;ol&gt; &lt;li v-for=&quot;salary in doubleSalaryByGetter&quot;&gt; {{salary.name}}的工资是：{{salary.salaryAmount}} &lt;/li&gt; &lt;/ol&gt; &lt;span&gt;工资总额是： {{totalSalaryByGetter}}&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { computed: { salaryList() { return this.$store.state.storeSalaryList; }, doubleSalaryByGetter() { return this.$store.getters.doubleSalaryGetter; }, // 增加获取工资总额的方法 totalSalaryByGetter() { return this.$store.getters.totalSalary; } }, }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 我们通过在当前页面调用 store.js 的 getter 方法，可以返回想要的结果。但是发现，在每个页面中，都要写调用写一个方法来调用 getter 也不是很方便。 Vuex 为我们提供了一个 mapGetters 辅助函数，可以用来获取getter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div id=&quot;salary-list-fisrt&quot;&gt; &lt;h2&gt;财富榜2&lt;/h2&gt; &lt;!-- &lt;ol&gt; &lt;li v-for=&quot;salary in doubleSalaryGetter &quot;&gt; {{salary.name}}的工资是：{{salary.salaryAmount}} &lt;/li&gt; &lt;/ol&gt; &lt;span&gt;工资总额是：{{totalSalary}}&lt;/span&gt; --&gt; &lt;ol&gt; &lt;li v-for=&quot;salary in myDoubleSalaryGetter &quot;&gt; {{salary.name}}的工资是：{{salary.salaryAmount}} &lt;/li&gt; &lt;/ol&gt; &lt;span&gt;工资总额是：{{myTotalSalary}}&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { mapGetters } from 'vuex'; export default { name: &quot;salary-list-two&quot;, computed: { salaryList() { return this.$store.state.storeSalaryList; }, doubleSalaryByGetter() { return this.$store.getters.doubleSalaryGetter; }, /** ...mapGetters( // 注意这里是个数组 [ 'doubleSalaryGetter','totalSalary' ] )*/ // ...mapGetters的另一种写法,通过这种方法可以给 getter 起别名 ...mapGetters( // 注意这里是一个对象 { myDoubleSalaryGetter: 'doubleSalaryGetter', myTotalSalary: 'totalSalary' }) } }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 运行结果如下： 3.mutations现在我们添加一个按钮，这个按钮的作用是，给 state 中的 storeSalaryList 增加工资，首先可以使用一个方法来改变 state App.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;salary-list-one&gt;&lt;/salary-list-one&gt; &lt;salary-list-two&gt;&lt;/salary-list-two&gt; &lt;button @click=&quot;moreSalary()&quot;&gt;加工资&lt;/button&gt; &lt;button @click=&quot;getAmount()&quot;&gt;显示工资&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import salarylist1 from './components/salarylist1'; import salarylist2 from './components/salarylist2'; export default { name: &quot;app&quot;, data() { return { }; }, components: { 'salary-list-one': salarylist1, 'salary-list-two': salarylist2 }, methods: { // 这个方法用来只增加工资 moreSalary() { this.$store.state.storeSalaryList.forEach(element =&gt; { element.salaryAmount += 100; }); }, // 这个方法用来显示 state 的工资内容 getAmount() { this.$store.state.storeSalaryList.forEach(element =&gt; { console.log(element.salaryAmount); }) } } };&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 运行结果： 分别点击 加工资 和 显示工资 按钮 （注：这里之所以点击一下加工资按钮每个人的工资增加 200 是因为，在两个子页面用的属性是 doubleSalaryGetter），由此可见 state 可见发生了变化。 但是直接调用方法，无法记录 store 中各种属性的变化，如果用 mutatios ，就可以使用 vue 的开发工具 Vue.js devtools，可以直观地观察 store 中的属性值变化。 在 store.js 增加一个 mutations 节点，并增加一个 moreSalaryMutation 属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);export const store = new Vuex.Store({ state: { storeSalaryList: [{ name: &quot;马云&quot;, salaryAmount: 1000 }, { name: &quot;马化腾&quot;, salaryAmount: 900 }, { name: &quot;李彦宏&quot;, salaryAmount: 800 } ] }, getters: { doubleSalaryGetter: (state) =&gt; { var afterDoubleSalary = state.storeSalaryList.map(salary =&gt; { return { name: salary.name, salaryAmount: salary.salaryAmount * 2 + &quot; &quot; + &quot;$&quot; }; }); return afterDoubleSalary; }, totalSalary: (state) =&gt; { var sum = 0 state.storeSalaryList.forEach(element =&gt; { sum += element.salaryAmount; }); return sum * 2; } }, mutations: { // 这个方法用来更改 state moreSalaryMutation: (state) =&gt; { state.storeSalaryList.forEach(element=&gt;{ element.salaryAmount += 100; }) } }}); 现在再增加一个按钮，使用mutations增加工资 AppVue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;salary-list-one&gt;&lt;/salary-list-one&gt; &lt;salary-list-two&gt;&lt;/salary-list-two&gt; &lt;button @click=&quot;moreSalary()&quot;&gt;加工资&lt;/button&gt; &lt;button @click=&quot;getAmount()&quot;&gt;显示工资&lt;/button&gt; &lt;button @click=&quot;moreSalaryByMutatios()&quot;&gt;使用matatios增加工资&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import salarylist1 from './components/salarylist1'; import salarylist2 from './components/salarylist2'; export default { name: &quot;app&quot;, data() { return { }; }, components: { 'salary-list-one': salarylist1, 'salary-list-two': salarylist2 }, methods: { moreSalary() { this.$store.state.storeSalaryList.forEach(element =&gt; { element.salaryAmount += 100; }); }, getAmount() { this.$store.state.storeSalaryList.forEach(element =&gt; { console.log(element.salaryAmount); }) }, // 这个方法调用 commit 来更改 state moreSalaryByMutatios() { this.$store.commit(&quot;moreSalaryMutation&quot;); } } };&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 运行结果如下： 值得注意的是，使用 commit 来更改 state ，我们可以借助Vue.js devtools很清晰地观测 state 的变化。 在Vuex的官方文档中有一句话 The only way to actually change state in a Vuex store is by committing a mutation. 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 在上面的例子中，我们发现不仅 commit 可以修改 state的值，通过一个普通的函数调用 moreSalary 方法也可以更改 state 的值，这好像和文档描述不相符。但是，如果在 store 创建的时候，申明为严格模式，再次调用moreSalary方法，就会报错。 store.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);export const store = new Vuex.Store({ // 在这里增加 严格模式 strict:true, state: { storeSalaryList: [{ name: &quot;马云&quot;, salaryAmount: 1000 }, { name: &quot;马化腾&quot;, salaryAmount: 900 }, { name: &quot;李彦宏&quot;, salaryAmount: 800 } ] }, getters: { doubleSalaryGetter: (state) =&gt; { var afterDoubleSalary = state.storeSalaryList.map(salary =&gt; { return { name: salary.name, salaryAmount: salary.salaryAmount * 2 + &quot; &quot; + &quot;$&quot; }; }); return afterDoubleSalary; }, totalSalary: (state) =&gt; { var sum = 0 state.storeSalaryList.forEach(element =&gt; { sum += element.salaryAmount; }); return sum * 2; } }, mutations: { moreSalaryMutation: (state) =&gt; { state.storeSalaryList.forEach(element=&gt;{ element.salaryAmount += 100; }) } }}); 再次点击加工资，就会出现报错 4. actions Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 现在我们将点击 使用matatios增加工资 改为5秒后产生效果。store.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);export const store = new Vuex.Store({ strict:true, state: { storeSalaryList: [{ name: &quot;马云&quot;, salaryAmount: 1000 }, { name: &quot;马化腾&quot;, salaryAmount: 900 }, { name: &quot;李彦宏&quot;, salaryAmount: 800 } ] }, getters: { doubleSalaryGetter: (state) =&gt; { var afterDoubleSalary = state.storeSalaryList.map(salary =&gt; { return { name: salary.name, salaryAmount: salary.salaryAmount * 2 + &quot; &quot; + &quot;$&quot; }; }); return afterDoubleSalary; }, totalSalary: (state) =&gt; { var sum = 0 state.storeSalaryList.forEach(element =&gt; { sum += element.salaryAmount; }); return sum * 2; } }, mutations: { moreSalaryMutation: state =&gt; { // 五秒之后加工资。 setTimeout(function(){ state.storeSalaryList.forEach(element=&gt;{ element.salaryAmount += 100; }) },5000) /*/state.storeSalaryList.forEach(element=&gt;{ element.salaryAmount += 100; })*/ } }}); 运行结果如下，等待5秒之后，虽然页面数值发生了变化，但是Vue.js dev-tools 却没有发生变化，而且还报错了。 报错如下 对此 Evan You 亲自给出了解释 在 store.js 中增加 actions 节点，并增加一个 moreSalaryAction 方法 store.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);export const store = new Vuex.Store({ strict:true, state: { storeSalaryList: [{ name: &quot;马云&quot;, salaryAmount: 1000 }, { name: &quot;马化腾&quot;, salaryAmount: 900 }, { name: &quot;李彦宏&quot;, salaryAmount: 800 } ] }, getters: { doubleSalaryGetter: (state) =&gt; { var afterDoubleSalary = state.storeSalaryList.map(salary =&gt; { return { name: salary.name, salaryAmount: salary.salaryAmount * 2 + &quot; &quot; + &quot;$&quot; }; }); return afterDoubleSalary; }, totalSalary: (state) =&gt; { var sum = 0 state.storeSalaryList.forEach(element =&gt; { sum += element.salaryAmount; }); return sum * 2; } }, mutations: { moreSalaryMutation: state =&gt; { // setTimeout(function(){ state.storeSalaryList.forEach(element=&gt;{ element.salaryAmount += 100; }) // },5000) /*/state.storeSalaryList.forEach(element=&gt;{ element.salaryAmount += 100; })*/ } }, actions:{ // 这个方法调用上面的 mutations 里边的 moreSalaryMutation // 点击3秒之后，运行mutation moreSalaryAction:(context)=&gt;{ setTimeout(function() { context.commit(&quot;moreSalaryMutation&quot;); },3000) } }}); 在 App.vue 中增加一个按钮 和 方法，点击按钮通过方法访问action App.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;salary-list-one&gt;&lt;/salary-list-one&gt; &lt;salary-list-two&gt;&lt;/salary-list-two&gt; &lt;button @click=&quot;moreSalary()&quot;&gt;加工资&lt;/button&gt; &lt;button @click=&quot;getAmount()&quot;&gt;显示工资&lt;/button&gt; &lt;button @click=&quot;moreSalaryByMutatios()&quot;&gt;使用matatios增加工资&lt;/button&gt; &lt;!-- 增加方法来调用 action --&gt; &lt;button @click=&quot;moreSalaryByActions()&quot;&gt;使用actions增加工资&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import salarylist1 from './components/salarylist1'; import salarylist2 from './components/salarylist2'; export default { name: &quot;app&quot;, data() { return { }; }, components: { 'salary-list-one': salarylist1, 'salary-list-two': salarylist2 }, methods: { moreSalary() { this.$store.state.storeSalaryList.forEach(element =&gt; { element.salaryAmount += 100; }); }, getAmount() { this.$store.state.storeSalaryList.forEach(element =&gt; { console.log(element.salaryAmount); }) }, moreSalaryByMutatios() { this.$store.commit(&quot;moreSalaryMutation&quot;); //this.$store.dispatch(&quot;moreSalaryAction&quot;); }, moreSalaryByActions() { // 通过此方法调用action this.$store.dispatch(&quot;moreSalaryAction&quot;); } } };&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 点击后我们发现 dev-tools 左边的方法记录和右边的 state 的值同时 改变，而且没有报错 Action中也可以传递参数。 我们设置一个工资增加的数目，通过 playload 来进行传递 App.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;salary-list-one&gt;&lt;/salary-list-one&gt; &lt;salary-list-two&gt;&lt;/salary-list-two&gt; &lt;button @click=&quot;moreSalary()&quot;&gt;加工资&lt;/button&gt; &lt;button @click=&quot;getAmount()&quot;&gt;显示工资&lt;/button&gt; &lt;button @click=&quot;moreSalaryByMutatios()&quot;&gt;使用matatios增加工资&lt;/button&gt; // 设置每次增加的数量 &lt;button @click=&quot;moreSalaryByActions(256)&quot;&gt;使用actions增加工资&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import salarylist1 from './components/salarylist1'; import salarylist2 from './components/salarylist2'; export default { name: &quot;app&quot;, data() { return { }; }, components: { 'salary-list-one': salarylist1, 'salary-list-two': salarylist2 }, methods: { moreSalary() { this.$store.state.storeSalaryList.forEach(element =&gt; { element.salaryAmount += 100; }); }, getAmount() { this.$store.state.storeSalaryList.forEach(element =&gt; { console.log(element.salaryAmount); }) }, moreSalaryByMutatios() { this.$store.commit(&quot;moreSalaryMutation&quot;); //this.$store.dispatch(&quot;moreSalaryAction&quot;); }, // 传递参数 moreSalaryByActions(amount) { this.$store.dispatch(&quot;moreSalaryAction&quot;, amount); } } };&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; store.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);export const store = new Vuex.Store({ strict:true, state: { storeSalaryList: [{ name: &quot;马云&quot;, salaryAmount: 1000 }, { name: &quot;马化腾&quot;, salaryAmount: 900 }, { name: &quot;李彦宏&quot;, salaryAmount: 800 } ] }, getters: { doubleSalaryGetter: (state) =&gt; { var afterDoubleSalary = state.storeSalaryList.map(salary =&gt; { return { name: salary.name, salaryAmount: salary.salaryAmount * 2 + &quot; &quot; + &quot;$&quot; }; }); return afterDoubleSalary; }, totalSalary: (state) =&gt; { var sum = 0 state.storeSalaryList.forEach(element =&gt; { sum += element.salaryAmount; }); return sum * 2; } }, mutations: { moreSalaryMutation: (state,amount) =&gt; { // setTimeout(function(){ state.storeSalaryList.forEach(element=&gt;{ element.salaryAmount += amount; }) // },5000) /*/state.storeSalaryList.forEach(element=&gt;{ element.salaryAmount += 100; })*/ } }, actions:{ // 传递参数 moreSalaryAction:(context,amount)=&gt;{ setTimeout(function() { context.commit(&quot;moreSalaryMutation&quot;,amount); },3000) } }}); 运行结果：工资以指定数值增减， 通过vue-tools 可以观测到 playload的变化 类似于 mapGetters, 可以调用 mapActions 来应对有很多 action 时的情况 App.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;salary-list-one&gt;&lt;/salary-list-one&gt; &lt;salary-list-two&gt;&lt;/salary-list-two&gt; &lt;button @click=&quot;moreSalary()&quot;&gt;加工资&lt;/button&gt; &lt;button @click=&quot;getAmount()&quot;&gt;显示工资&lt;/button&gt; &lt;button @click=&quot;moreSalaryByMutatios()&quot;&gt;使用matatios增加工资&lt;/button&gt; &lt;button @click=&quot;moreSalaryByActions(256)&quot;&gt;使用actions增加工资&lt;/button&gt; &lt;!-- &lt;button @click=&quot;moreSalaryAction(256)&quot;&gt;使用mapActions增加工资&lt;/button&gt; --&gt; &lt;button @click=&quot;myMoreSalaryAction(256)&quot;&gt;使用mapActions增加工资&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import salarylist1 from './components/salarylist1'; import salarylist2 from './components/salarylist2'; import { mapActions } from 'vuex' export default { name: &quot;app&quot;, data() { return { }; }, components: { 'salary-list-one': salarylist1, 'salary-list-two': salarylist2 }, methods: { moreSalary() { this.$store.state.storeSalaryList.forEach(element =&gt; { element.salaryAmount += 100; }); }, getAmount() { this.$store.state.storeSalaryList.forEach(element =&gt; { console.log(element.salaryAmount); }) }, moreSalaryByMutatios() { this.$store.commit(&quot;moreSalaryMutation&quot;); //this.$store.dispatch(&quot;moreSalaryAction&quot;); }, moreSalaryByActions(amount) { this.$store.dispatch(&quot;moreSalaryAction&quot;, amount); }, ...mapActions([ // `mapActions` 也支持载荷： 'moreSalaryAction' // 将 `this.moreSalaryAction(amount)` 映射为 `this.$store.dispatch('moreSalaryAction', amount)` ]), // mapActions 的 第二种写法 ...mapActions({ myMoreSalaryAction:'moreSalaryAction' }) } };&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","link":"/2018/12/11/Vuex%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"}],"categories":[]}